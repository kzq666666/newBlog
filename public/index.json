[{"authors":null,"categories":null,"content":"\n客官，欢迎来到我的博客网站，welcome~💃💃💃 一名在校大四学生，目前正在修的本专业是生物工程，双学位是计算机科学与技术 主要分享一些我的学习经验和生活感想，也是对学习和生活的记录 有什么疑问或者其他的都可以联系我 ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":-62135596800,"objectID":"598b63dd58b43bce02403646f240cd3c","permalink":"https://kangzhiqing.com/author/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/admin/","section":"author","summary":"客官，欢迎来到我的博客网站，welcome~💃💃💃 一名在校大四学生，目前正在修的本专业是生物工程，双学位是计算机科学与技术 主要分享一些我的学","tags":null,"title":"","type":"author"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":-62135596800,"objectID":"d41d8cd98f00b204e9800998ecf8427e","permalink":"https://kangzhiqing.com/author/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/","section":"author","summary":"","tags":null,"title":"Authors","type":"author"},{"authors":null,"categories":[],"content":" 毛中特 五四运动的进步性  彻底的反帝反封建 是一场真正的群众运动，群众运动的广泛性 追求救国强国真理的进步性，新思想、新文化、新知识的思想启蒙运动  五四运动对中国共产党的意义  五四运动是中国近现代历史上具有里程碑意义的重大时间。五四运动为中国共产党的成立作了思想和干部上的准备 五四运动实现了中国任命和中华民族自鸦片战争以来的第一次全面觉醒 五四运动让中国人民和中华民族明白了，实现中华民族的伟大复兴，必须依靠自己的英勇奋斗来实现  五四精神 爱国、进步、民主、科学为主要内容的五四精神，体现了中国人民和中华民族近代以来追求的先进价值观，也是中国共产党领导革命、建设、改革的精神动力 - 五四精神以爱国主义为核心 - 五四运动激发了全民族的伟大觉醒 - 五四运动体现了顽强的斗争精神\n经济全球化  经济全球化是历史大势、时代潮流，不可逆转、不可阻拦 世界各国日益利益交融、命运与共，合作共赢是时代大势 开放带来进步，封闭必然落后，应该坚持以开放求发展，深化交流合作，坚持拉手，而不是松手，坚持拆墙，而不是筑墙  如何应对经济全球化，把发展的动力搞大，阻力搞小  坚持人类优先的理念，而不应该把一己利益凌驾于人类利益至上 秉持更加开放的心态，采取更加开放的举措，共建开放合作，开放创新，开放共享的世界经济  中美关系 文明冲突  说成是文明冲突是美国极少数政客和极右主义者的借口 中国始终认为多样性不仅是世界文化的基本特征，也是人类文明进步的重要动力。文明是多彩的、平等的、包容的、发展的 多样而交流，交流而互鉴，互鉴而发展 中国是维护世界文化多样性的倡导者、践行者。中国坚持相互尊重、平等相待；坚持美人之美、美美与共；坚持开放包容、互学互鉴；坚持与时俱进、创新发展  实体经济  实体经济是一国经济的立身之本、财富之源，是国家富强的重要支柱，是我们现代化经济体系的坚实基础，是我国巩固未来发展战略优势的重要支撑 制造业是实体经济的基础，抓实体经济一定要抓好制造业 一个国家要提高竞争力，归根结底要靠实体经济，无论经济发展到什么水平，实体经济都是我国经济发展的根基  创新  一个国家和民族的创新能力，从根本上影响甚至决定国家和民族的前途命运，当今经济社会的发展越来越依靠理论、制度、科学、文化的创新 我国创新能力不强，关键技术还受制于人。要想把我国实体经济和制造业搞上去，也必须坚持创新驱动发展战略，通过创新引领和驱动制造业高质量发展 是改革开放以来，长期得出来得结论，是应对环境变化，增强发展动力的根本之策  区域协调发展  区域协调发展是新发展理念的要求，协调是持续健康发展的内在要求 城乡区域协调发展是建设现代化经济体系的需要，区域协调发展能够优化现代化经济体系的空间布局，不断增强区域发展的协同性，全面提高资源配置效率，为经济高质量发展注入澎湃动力 积极推动区域协调发展是我国发展中不平衡、不协调、不可持续的突出问题的一个重要途径，既是全面小康社会的要求，也是不断解决新时代主要矛盾的需要  不忘初心 牢记使命  根本动力 根本原因 初心和使命是中国共产党的性质宗旨、理想信念 越是长期执政，越不能忘记马克思政党的本色，越不能忘记党的初心和使命，越不能忘记自我革命的精神 忘记初心和使命，中国共产党就会失去颜色，失去性质，失去人民，失去未来\n为什么要强烈的自我革命精神  ","date":1576375497,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1576375497,"objectID":"e0bba2ab96ac5a91b7cc4cef70ca8848","permalink":"https://kangzhiqing.com/study/%E8%82%96%E5%9B%9B/","publishdate":"2019-12-15T10:04:57+08:00","relpermalink":"/study/%E8%82%96%E5%9B%9B/","section":"study","summary":"毛中特 五四运动的进步性 彻底的反帝反封建 是一场真正的群众运动，群众运动的广泛性 追求救国强国真理的进步性，新思想、新文化、新知识的思想启蒙运动 五","tags":[],"title":"肖四","type":"study"},{"authors":null,"categories":null,"content":" TV动画《刀剑神域 Alicization篇 War of Underworld》片尾曲 歌手：LiSA 一人きりでも 我一个人也没关系\n平気へいきとこぼれ落おちた強つよがり 脱口而出的又是逞强的话语\n二人ふたりの眩まぶしすぎた日が 和你共度的那段时光太耀眼\nこんなに悲かなしい 如今只剩下无尽的哀伤\n一人で生いきられるなら 如果可以一个人活下去\n誰かを愛したりしないから 也就不会爱上某个人了吧\nあなたの香かおり あなたの話はなし方かた 你散发的气息 你说话的方式\n今も体からだ中じゅうに 愛の欠片かけらが残のこってるよ 至今仍在我的全身留下些微爱的碎片\n私の願い 私の願いはただ 我的愿望 我唯一的愿望\nどうかあなたも何処どこかで 仅仅是希望你也同样正在某处\n泣ないていますように 潸然落泪\nいつも新あたらしい一歩いっぽは 斩断过去踏出新的一步\n重おもくて寂さびしい 总是沉重而寂寞\nもし生うまれ変かわっても 若可以转世重生\nもう一度いちどあなたに出会であいたい 我还想再次和你相遇\n真夏まなつの日差ひざし 真冬まふゆの白しろい雪ゆき 盛夏的烈阳 隆冬的白雪\nめぐる季節きせつ中じゅうに 四季不停轮转更替\n愛の欠片かけらが舞まい落おちて 爱的碎片飘落而下\n幸せなのに どこかで寂さびしいのは 明明如此幸福却又感到一丝落寞\nあなたよりも大おきな 私の愛のせい 一定是因为我所付出的爱 远胜于你\n鍵かぎはあなたが持もったまま 那把钥匙依旧握于你的手中\n歌うたう意味いみを失なくしたカナリア 失去了歌唱的意义的金丝雀\n暗くらい鳥籠とりかごの中なかで 困在这昏暗无光的鸟笼之中\nあなたの香かおり あなたの話はなし方かた 你散发的气息 你说话的方式\n今も身体からだ中じゅうに 至今仍在我的全身\n愛の欠片かけらが残のこってるよ 留下些微爱的碎片\n私の願い 私の願いはただ 我的愿望 我唯一的愿望\nどうかあなたが幸せで 仅仅是希望你\nありますように 一定要幸福\nUnlasting world 转瞬即逝的世界\nThe course of love 爱的历程\nFrom everything think of you 从每件事中想到你\n","date":1575173902,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1575173902,"objectID":"f7fa4533b68d6d69f88db4ef3a3af8fd","permalink":"https://kangzhiqing.com/life/unlasting/","publishdate":"2019-12-01T12:18:22+08:00","relpermalink":"/life/unlasting/","section":"life","summary":"TV动画《刀剑神域 Alicization篇 War of Underworld》片尾曲 歌手：LiSA 一人きりでも 我一个人也没关系 平気へいきとこぼれ落おち","tags":["music"],"title":"Unlasting","type":"life"},{"authors":null,"categories":null,"content":" やっと眼めを覚さましたかい　 总算睡醒了吗？\nそれなのになぜ眼めも合あわせやしないんだい? 可你为什么不肯对上我的视线呢？\n遅おそいよと怒おこる君きみ 你生气地责怪我怎么那么晚到\nこれでもやれるだけ 飞とばしてきたんだよ 可即便如此我也已经尽我所能 以最快的速度飞奔到你的身边\n心こころが身体からだを追おい越こしてきたんだよ 心脏甚至比身体先一步抵达了这里\n君きみの髪かみや瞳ひとみだけで胸むねが痛いたいよ 只是望着你的发丝和你的眼眸就让我痛彻心扉\n同おなじ时ときを吸すいこんで 离はなしたくないよ 想和你呼吸在当下 再也不想和你分开\n遥はるか昔むかしから知しるその声こえに 很久很久以前就熟稔于心的声音\n生うまれて はじめて 何なにを言いえばいい? 有生以来第一次烦恼着 该如何回应？\n君きみの前前前世ぜんぜんぜんせから僕ぼくは 从你的前前前世开始\n君きみを探さがし はじめたよ 我就一直在寻找你的踪迹\nそのぶきっちょな 笑わらい方かたをめがけてやってきたんだよ 循着你那笨拙的笑容 总算找到了这个地方\n君きみが全然全部ぜんぜんぜんぶなくなって チリヂリになったって 就算你的一切化为乌有 支离破碎散落世界各处\nもう迷まよわない またから探さがし はじめるさ 我也不会再迷茫 我会从头开始再一次寻找\nむしろ0から また宇宙うちゅうを はじめてみようか 不如说就这样从零开始 再创造一个全新的宇宙\n（何光こう年でも この歌うたを口くずさみながら） 无论跨越多少光年 我都会哼着这首歌 再度找到你 どっから话はなすかな 该从哪儿说起呢\n君きみが眠ねむっていた间あいだのストーリー 在你沉睡这段期间的故事\n何亿なんおく 何光年なんこうねん分ぶんの物语ものがたりを 语がたりにきたんだよ 历经上亿光年所编织的故事 我就是为了将其述说而来到这里的\nけどいざその姿すがたこの眼めに映うつすと 但是当你的身影映入我的眼帘\n君きみも知しらぬ君きみとジャレて戯たわむれたいよ 我却想和你也不曾知晓的自己说笑玩闹\n君きみの消きえぬ痛いたみまで 爱あいしてみたいよ 包括长久纠缠你的苦痛 我也想一并地爱惜包容\n银河ぎんが何个分なんこぶんかの果はてに出逢であえた 跨过几个银河终在尽头相逢\nその手てを壊こわさずにどう握にぎったならいい? 你的双手我该如何小心翼翼又牢牢抓住呢?\n君きみの前前前世ぜんぜんぜんせから僕ぼくは 从你的前前前世开始\n君きみを探さがし はじめたよ 我就一直在寻找你的踪迹\nその騒さわがしい声こえと涙なみだをめがけ やってきたんだよ 循着那喧嚣的噪音和你的眼泪 总算找到了这个地方\nそんな革命かくめい前夜ぜんやの僕ぼくらを 处于革命前夜的我们\n谁だれが止との僕ぼくめるというんだろう 你说还有谁能阻止呢\nもう迷まよわない君きみのハートに旗はたを立たてるよ 我已经不会再迷茫 在你的心中竖起属于我的旗帜\n君きみは僕ぼくから谛あきらめ方かたを夺うばい取とったの 我放弃的念头早就被你夺走了\n前前前世ぜんぜんぜんせから僕ぼくは 从你的前前前世开始\n君きみを探さがし はじめたよ 我就一直在寻找你的踪迹\nそのぶきっちょな 笑わらい方かたをめがけて やってきたんだよ 循着你那笨拙的笑容 总算找到了这个地方\n君きみが全然全部ぜんぜんぜんぶなくなってチリヂリになったって 就算你的一切化为乌有 支离破碎散落世界各处\nもう迷まよわない また1から探さがし はじめるさ 我也不会再迷茫 我会从头开始再一次寻找\n何光こう年でも この歌うたを口ずさみながら 无论跨越多少光年 我都会哼着这首歌 再度找到你\n","date":1574510221,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1574510221,"objectID":"274a6e33daa7e1596fc3ccf3c87c991a","permalink":"https://kangzhiqing.com/life/%E5%89%8D%E5%89%8D%E5%89%8D%E4%B8%96/","publishdate":"2019-11-23T19:57:01+08:00","relpermalink":"/life/%E5%89%8D%E5%89%8D%E5%89%8D%E4%B8%96/","section":"life","summary":"やっと眼めを覚さましたかい 总算睡醒了吗？ それなのになぜ眼めも合あわせやしないんだい? 可你为什么不肯对上我的视线呢？ 遅おそいよと怒おこる君きみ","tags":["music"],"title":"前前前世","type":"life"},{"authors":null,"categories":null,"content":" HTML html5特性  增加了canvus画布 增加了用于视频播放的video和音频的audio，可以直接在页面播放视频和音频而不需要任何的插件 增加了许多语义化的标签，header、article、footer等等 增加了用于本地离线存储的localStorage和sessionStorage\nCSS 盒模型 标准盒模型(content-box):height = content\n IE合模型(border-box):height = content + padding + border\n水平居中和垂直居中一些方式 (水平)行内元素：text-align：center;line-height:父元素高度\n (水平)块级元素：margin：0 auto;\n (垂直)：display:table-cell;vertical-align:middle;\n (水平垂直)已知高度：position:absolute;left:50%;top:50%;margin-left:自身宽度的一半;margin-top:-50%;\n (水平垂直)未知高度：position:absolute;left:50%;top:50%;transform:translate(-50%,-50%)\n (水平垂直)未知高度position:absolute;left:0;right:0;top:0;bottom:0;margin:auto;\n (水平垂直)未知高度display:flex;justify:center(水平居中);align-items:center;(垂直居中)\n  什么是BFC？怎么理解  BFC(Block Formatting Context):块级格式上下文；它规定块级元素内部如何布局 内部定位方案：  内部的盒子按垂直方向一个接一个   JS VUE 网络 TCP和UDP的区别和优缺点  TCP和UPD都是传输层的TCP/IP网络协议的，作用都是用来传输和接受数据 TCP面向连接的，通讯之前必须保证双方连接上，三次握手。UDP面向无连接的，通讯之前不需要连接 TCP能保证数据可靠和顺序性。UDP则不能保证，传输过程会出现丢包现象 TCP复杂些，报文字节数多。UPD简单快速，报文字节少  浏览器  Chrome：webkit/blink Safari: webkit IE：Trident FireFox：Gecko Opera：Presto  ","date":1570866208,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1570866208,"objectID":"b504f160529b13972d23c0ac0ed8d4bf","permalink":"https://kangzhiqing.com/study/%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/","publishdate":"2019-10-12T15:43:28+08:00","relpermalink":"/study/%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/","section":"study","summary":"HTML html5特性 增加了canvus画布 增加了用于视频播放的video和音频的audio，可以直接在页面播放视频和音频而不需要任何的插件 增加了","tags":null,"title":"前端常用知识点复习","type":"study"},{"authors":null,"categories":null,"content":" 前言 开篇日记，记录一哈自己的日常生活和学习以及一些思考\n2019年10月12日 昨晚有些失眠，今天早上起得晚，起来就快九点了，在室友的鼓动之下以及自己疲劳的状态加持，下了一上午的棋，云顶之奕真香，枪剑恰起来。下午收到恒生的面试通知，讲真我昨天去笔试的时候我感觉自己挺菜的，很多题目都写不出来，挺意外，既然如此，明天面试就要好好的准备一下，最近都没怎么写代码，很多知识点都忘记了。\n2019年10月13日 今天呢，主要去恒生面试，在秋水广场附近的一个酒店，别的不说，那酒店是真大（一幅没见过世面的亚子。。。），讲真，今年就没怎么写代码，忙着考研，所以这次面试也是抱着试一试的态度，学习一下面试的技巧，感受一下面试的氛围。面试过程感觉自己还是蛮菜的，很多知识都没有真正的理解和掌握，基础和底层的问的比较多一些，很多问题都没答得很满意，基本是没了。那明天就好好的开始准备考研的事情了，加油吧。\n2019年10月20日 上次顺便和室友一起去面了中联重科，今天拿到offer了。因为都在前湖那边，所以这几天主要都花在坐车上了，也没怎么学习，秋招就结束了，也不想去面其他企业了。明天开始，重整旗鼓，好好学习喽~\n2019年11月1日 11月啦，过的好快，还有好多没复习的\u0026hellip; 革命尚未成功，同志还需努力\n","date":1570865727,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1570865727,"objectID":"20170364dc295cb5c37274a2396da392","permalink":"https://kangzhiqing.com/life/diary/","publishdate":"2019-10-12T15:35:27+08:00","relpermalink":"/life/diary/","section":"life","summary":"前言 开篇日记，记录一哈自己的日常生活和学习以及一些思考 2019年10月12日 昨晚有些失眠，今天早上起得晚，起来就快九点了，在室友的鼓动之下以","tags":null,"title":"Diary","type":"life"},{"authors":null,"categories":null,"content":" 梦 ゆめならば\u0026emsp;どれほど\u0026emsp;よかったでしょう 如果这一切都是梦境该有多好\n未 いまだに\u0026emsp;あなたの\u0026emsp;ことを\u0026emsp;梦 ゆめにみる 至今仍能与你在梦中相遇\n忘 わすれた 物 ものを 取 とりに 帰 かえるように 如同取回遗忘之物一般\n古 ふるびた 思 おもい 出 での 埃 ほこりを 払 はらう 细细拂去将回忆覆盖的尘埃\n戻 もどらない 幸 しあわせがあることを 这世间亦有无法挽回的幸福\n最後 さいごにあなたが 教 おしえてくれた 最终是你让我懂得这一点\n言 いえずに 隠 かくしてた 昏 くらい过去 かこも 那些未对他人提及过的黑暗往事\nあなたがいなきゃ 永远 えいえんに 昏 くらいまま 如果不曾有你的话 它们将永远沉睡在黑暗中\nきっともうこれ 以上 いじょう伤きずつくことなど 比这更令人难过的事情\nありはしないとわかっている 我知道不可能存在\nあの 日 ひの 悲 かなしみさえ 那日的悲伤\nあの 日 ひの 苦 くるしみさえ 与那日的痛苦\nそのすべてを 爱 あいしてた\u0026emsp;あなたとともに 连同深爱着这一切的你\n胸 むねに 残 のこり 离 はなれない 化作了深深烙印在我心中的\n苦 にがいレモンの 匂 におい 苦涩柠檬的香气\n雨 あめが 降 ふり 止 やむまでは 帰 かえれない 在雨过天晴前都无法归去\n今いま\u0026emsp;でも\u0026emsp;あなたは\u0026emsp;わたしの 光 ひかり 时至今日 你仍是我的光芒 暗闇 くらやみであなたの 背 せをなぞった 在黑暗中追寻着你的身影\nその 轮郭 りんかくを 鲜明 せんめいに 覚 おぼえている 那轮廓至今仍鲜明地刻印于心\n受 うけ 止 とめきれないものと 出会 であうたび 每当遇到无法承受的苦痛时\n溢 あふれてやまないのは涙 なみだだけ 总不禁泪如泉涌\n何 なにをしていたの 你都经历过什么\n何 なにを 见 みていたの 又目睹过什么呢\nわたしの 知 しらない 横颜 よこがおで 脸上浮现着我不曾见过的神情\nどこかであなたが 今 いま 如果你正在什么地方\nわたしと 同 おなじ 様 ような 与我一样\n涙 なみだにくれ 淋 さびしさの 中 なかにいるなら 终日过着以泪洗面的寂寞生活的话\nわたしのことなどどうか 忘 わすれてください 就请你将我的一切全部遗忘吧\nそんなことを 心 こころから 願 ねがうほどに 这是我发自内深处唯一的祈愿\n今 いま\u0026emsp;でも\u0026emsp;あなたは\u0026emsp;わたしの 光 ひかり 时至今日 你仍是我的光芒 自分じぶんが 思 おもうより \u0026emsp;恋 こいをしていたあなたに 我深深地恋慕着你 甚至超出了我自己的想象\nあれから 思 おもうように \u0026emsp;息 いきができない 自此每当想起你 都如同窒息般痛苦\nあんなに 侧 そばにいたのに \u0026emsp;まるで 嘘 うそみたい 你曾亲密伴我身旁 如今却如烟云般消散\nとても 忘 わすれられない \u0026emsp;それだけが 确 たしか 唯一能确定的是 我永远都不会将你遗忘\nあの 日 ひの 悲 かなしみさえ 那日的悲伤\nあの 日 ひの 苦 くるしみさえ 与那日的痛苦\nその 全 すべてを 爱 あいしてたあなたと 共 ともに 连同深爱着这一切的你\n胸 むねに 残 のこり 离 はなれない 化作了深深烙印在我心中的\n苦 にがいレモンの 匂 におい 苦涩柠檬的香气\n雨 あめが 降 ふり 止 やむまでは 帰 かえれない 在雨过天晴前都无法归去\n切 きり 分 わけた 果実 かじつの 片方 かたほうの 様 ように 如同被切开的半个柠檬一般\n今いま\u0026emsp;でも\u0026emsp;あなたは\u0026emsp;わたしの 光 ひかり 时至今日你仍是我的光芒\n","date":1559958137,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1559958137,"objectID":"7e40864642931a8f03df91cd5ca32e81","permalink":"https://kangzhiqing.com/life/lemon/","publishdate":"2019-06-08T09:42:17+08:00","relpermalink":"/life/lemon/","section":"life","summary":"梦 ゆめならば\u0026emsp;どれほど\u0026emsp;よかったでしょう 如果这一切都是梦境该有多好 未 いまだに\u0026emsp;あなたの\u0026emsp;ことを\u0026em","tags":[],"title":"Lemon","type":"life"},{"authors":null,"categories":null,"content":" 解决jupyter notebook 运行之后为空页面 1.打开cmd = \u0026gt;register 2.找到HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes.js 3.把content Type : text/plain =\u0026gt; application/javascript\nelectron-builder打包过程的错误 在可以科学上网的情况还是出现了该bug，只能选择手动下载对应的包了 ，这里报错是要下载winCodeSign-2.4.0，之后也会报错相应的包，就手动去下载对应的包 下载传送门 之后解压到 =\u0026gt; C:\\Users\\KZQ\\AppData\\Local\\electron-builder\\Cache 切记，一定要在上面路径下先创建一个叫做winCodeSign的路径，然后将winCodeSign-2.4.0解压到winCodeSign路径。其他的包也是如此 ","date":1559289758,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1559289758,"objectID":"9b87f95503399cb6b30df9d95b8b187d","permalink":"https://kangzhiqing.com/post/hole/","publishdate":"2019-05-31T16:02:38+08:00","relpermalink":"/post/hole/","section":"post","summary":"解决jupyter notebook 运行之后为空页面 1.打开cmd = \u0026gt;register 2.找到HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes.js 3","tags":null,"title":"坑","type":"post"},{"authors":null,"categories":null,"content":" 水波效果  .waterWaves{ position: relative; width: 200px; height: 200px; border: 1px solid #999; border-radius: 50%; text-align: center; line-height: 100px; margin: 100px auto; animation: wave linear infinite; overflow:hidden; } .wave1{ position: absolute; width: 200%; height: 200%; background:skyblue; opacity: 0.4; left: -50%; top: 50%; border-radius: 180px; animation: inherit; animation-duration: 7s; } .wave2{ position: absolute; width: 200%; height: 200%; background:skyblue; opacity: 0.6; left: -30%; top: 60%; border-radius: 45%; animation: inherit; animation-duration: 10s; } .wave3{ position: absolute; width: 200%; height: 200%; background:skyblue; opacity: 0.8; left: -50%; top: 55%; border-radius: 45%; animation: inherit; animation-duration: 7s; } @keyframes wave{ 0%{ transform: rotate(0deg); } 100%{ transform: rotate(360deg); } }     WaterWave  主要利用子元素的旋转实现，具体代码如下\n\u0026lt;div class=\u0026quot;waterWaves\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;wave1\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;wave2\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;wave3\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; WaterWave \u0026lt;/div\u0026gt;  .waterWaves { position: relative; width: 200px; height: 200px; border: 1px solid #999; border-radius: 50%; text-align: center; line-height: 100px; margin: 100px auto; animation: wave linear infinite; overflow: hidden; } .wave1 { position: absolute; width: 200%; height: 200%; background: skyblue; opacity: 0.4; left: -50%; top: 50%; border-radius: 180px; animation: inherit; animation-duration: 7s; } .wave2 { position: absolute; width: 200%; height: 200%; background: skyblue; opacity: 0.6; left: -30%; top: 60%; border-radius: 45%; animation: inherit; animation-duration: 10s; } .wave3 { position: absolute; width: 200%; height: 200%; background: skyblue; opacity: 0.8; left: -50%; top: 55%; border-radius: 45%; animation: inherit; animation-duration: 13s; } @keyframes wave { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }  ","date":1558599063,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1558599063,"objectID":"2eb4ed224deecd184c3033bef10a13d8","permalink":"https://kangzhiqing.com/post/cssdemo/","publishdate":"2019-05-23T16:11:03+08:00","relpermalink":"/post/cssdemo/","section":"post","summary":"水波效果 .waterWaves{ position: relative; width: 200px; height: 200px; border: 1px solid #999; border-radius: 50%; text-align: center; line-height: 100px; margin: 100px auto; animation: wave linear infinite; overflow:hidden; } .wave1{ position: absolute; width: 200%; height: 200%; background:skyblue; opacity: 0.4; left: -50%; top: 50%; border-radius: 180px; animation: inherit; animation-duration: 7s; } .wave2{ position: absolute; width: 200%; height: 200%; background:skyblue; opacity: 0.6; left: -30%; top: 60%; border-radius: 45%; animation: inherit; animation-duration:","tags":["CSS","demo"],"title":"CSSDemo","type":"post"},{"authors":null,"categories":null,"content":" 数组去重 function noRepeat(arr){ return arr.filter((ele,index)=\u0026gt;{ return arr.indexOf(ele) == index; }) }  ","date":1556328317,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1556328317,"objectID":"53671db4c339f32c9f16a6a579e4d939","permalink":"https://kangzhiqing.com/post/jsalg/","publishdate":"2019-04-27T09:25:17+08:00","relpermalink":"/post/jsalg/","section":"post","summary":"数组去重 function noRepeat(arr){ return arr.filter((ele,index)=\u0026gt;{ return arr.indexOf(ele) == index; }) }","tags":null,"title":"JsAlg","type":"post"},{"authors":null,"categories":[],"content":" SVG(Scalable Vector Graphics 可伸缩矢量图) 历史 2001年推出第一版，一直在发展，但直到高分辨率设备出现才得到广泛的关注和使用\n定义 SVG是XML中用于描述二维图形的语言，SVG支持三种图形对象矢量图形形状、图像、文本\n代码实例 五角星 Star 1 Created with Sketch.    \n\u0026lt;!-- 0 0 198 198 min-x min-y 宽度 高度 --\u0026gt; \u0026lt;svg width=\u0026quot;198px\u0026quot; height=\u0026quot;188px\u0026quot; viewBox=\u0026quot;0 0 198 188\u0026quot; version=\u0026quot;1.1\u0026quot; xmlns=\u0026quot;http://www.w3.org/2000/svg\u0026quot; xmlns:xlink=\u0026quot;http://www.w3.org/1999/xlink\u0026quot; xmlns:sketch=\u0026quot;http://www.bohemiancoding.com/sketch/ns\u0026quot;\u0026gt; \u0026lt;!--title和desc是在图片没有加载出来时候的展现出来的信息 --\u0026gt; \u0026lt;title\u0026gt;Star 1\u0026lt;/title\u0026gt; \u0026lt;desc\u0026gt;Created with Sketch.\u0026lt;/desc\u0026gt; \u0026lt;!--defs用于存储所有可以复用的元素定义的地方，如梯度、符号、路径--\u0026gt; \u0026lt;defs\u0026gt;\u0026lt;/defs\u0026gt; \u0026lt;!--g标签是group的缩写，可以把其他元素捆绑在一起使用--\u0026gt; \u0026lt;g id=\u0026quot;Page-1\u0026quot; stroke=\u0026quot;none\u0026quot; stroke-width=\u0026quot;1\u0026quot; fill=\u0026quot;none\u0026quot; fill-rule=\u0026quot;evenodd\u0026quot; sketch:type=\u0026quot;MSPage\u0026quot;\u0026gt; \u0026lt;!--多边形节点（polygon），内置还有path、rect、circle、ellipse、--\u0026gt; \u0026lt;polygon id=\u0026quot;Star-1\u0026quot; stroke=\u0026quot;#979797\u0026quot; stroke-width=\u0026quot;3\u0026quot; fill=\u0026quot;#F8E81C\u0026quot; sketch:type=\u0026quot;MSShapeGroup\u0026quot; points=\u0026quot;99 154 40.2214748 184.901699 51.4471742 119.45085 3.89434837 73.0983006 69.6107374 63.5491503 99 4 128.389263 63.5491503 194.105652 73.0983006 146.552826 119.45085 157.778525 184.901699 \u0026quot;\u0026gt;\u0026lt;/polygon\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;/svg\u0026gt;  在页面上插入SVG  img html \u0026lt;img src=\u0026quot;1.svg\u0026quot; alt=\u0026quot;a svg\u0026quot;/\u0026gt;  object html \u0026lt;object type=\u0026quot;image/svg+xml\u0026quot; data=\u0026quot;1.svg\u0026quot;\u0026gt; \u0026lt;span\u0026gt;your browser donot support svg\u0026lt;/span\u0026gt; \u0026lt;/object  背景图片插入 内联  ","date":1554968327,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1554968327,"objectID":"d221f09f9f9b21ea6da043b2e4e07a37","permalink":"https://kangzhiqing.com/post/svg/","publishdate":"2019-04-11T15:38:47+08:00","relpermalink":"/post/svg/","section":"post","summary":"SVG(Scalable Vector Graphics 可伸缩矢量图) 历史 2001年推出第一版，一直在发展，但直到高分辨率设备出现才得到广泛的关注和使用 定义 SVG是XML中用于描述二维图形的","tags":[],"title":"SVG","type":"post"},{"authors":null,"categories":null,"content":" 媒体查询 meta标签 针对视口的标签，告诉浏览器该如何渲染当前页面，是网页和移动浏览器的接口\n\u0026lt;!-- viewport:视口 width为设备宽度 初始化页面大小为实际大小的1.0倍 禁止用户缩放 --\u0026gt; \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width,initial-scale=1.0,user-scalable=no\u0026quot;/\u0026gt;  弹性布局与响应式图片 Flexbox  方向  flex-direction row:水平方向（起点是最左端） row-reverse:水平反方向（起点是最右端） column:垂直方向（起点是最上方） column-reverse:垂直反方向（起点是最下方）  主轴和交叉轴  FlexBox方向是row，主轴就是横轴，交叉轴就是与之垂直的纵轴 FlexBox方向是column，主轴就是纵轴，交叉轴就是横轴  对齐  align-item:交叉轴对齐方式  flex-start:从flexbox父元素起始边对齐 flex-end:从flexbox父元素末尾对齐 center:从flexbox父元素居中对齐 baseline:沿基线对齐 stretch:所有项拉伸至父元素一样大（默认）  slign-self:单个元素的对齐方式 justify-content:主轴对齐方式  flex-start(默认) flex-end center space-between:每个子元素的之间空白间距一样 space-around:每个子元素的两端空白间距都一样   flex(flex-grow flex-shrink flex-basis)  flex-grow:相对于其他的项目的放大/伸张比例 flex-shrink:相对于其他的项目的缩小/收缩比例 flex-basis:项目占据的主轴空间，默认是auto  弹性  ","date":1554193569,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1554193569,"objectID":"845573547d3be52ab793b062f56fcd08","permalink":"https://kangzhiqing.com/post/reswebdesign/","publishdate":"2019-04-02T16:26:09+08:00","relpermalink":"/post/reswebdesign/","section":"post","summary":"媒体查询 meta标签 针对视口的标签，告诉浏览器该如何渲染当前页面，是网页和移动浏览器的接口 \u0026lt;!-- viewport:视口 width为设备宽度 初始化","tags":null,"title":"ResWebDesign","type":"post"},{"authors":null,"categories":[],"content":" 目标  Name Content   目标专业 计算机科学与技术   专业方向 WEB 开发  目标院校 浙江大学   目标分数 380  --  \n购买书籍汇总  科目 书籍   数学   张宇高等数学18讲\n  李永乐线性代数辅助讲义\n  王式安概率论与数理统计辅助讲义   张宇考研数学1000题   408   王道复习全书\n\n 数学 2019年3月4日 =\u0026gt; 复习完线代行列式和矩阵基本知识 2019年5月23日 =\u0026gt; 复习完线代，高数才复习到第二讲（有点慢）\n英语 2019年3月4日 =\u0026gt; 考研单词已背1000 2019年5月23日 =\u0026gt; 考研单词已背4000\n政治 408 数据结构 操作系统 计算机组成和原理 2019年5月23日 =\u0026gt; 看完一遍王道（里面题目还没做完），自我感觉计组还是比较难的\n计算机网络 2019年5月23日 =\u0026gt; 复习到第三章数据链路层\n2019 年 2 月 了解考研基本的情况和复习的准备，需要购买什么资料、看什么视频，这些在知乎、b 站、贴吧都有对应的信息,并购买相应的资料\n2019 年 3 月 4 日 这个学期已经过去一个星期了，这个学期课还算是比较多的，加上双学位的课，确实有些忙碌。考研的路刚刚开始，但感觉自己的效率还是比较低，可能是太久没有这样准备考试了，总而言之，路是要慢慢的走的，踏踏实实的完成每日的复习任务。\n2019 年 5 月 23 日 考研呢，是一件短期收益较低的事情，贵在坚持，我觉得这个过程真的是和自己对抗更多，大多时候还是要对自己狠点，不然惰性一上来效率什么的就没了 还有执行力有待提高，说做一件事还是要立马去做，拖一下就基本不做了 最后呢，加油呢~\n","date":1551670143,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1551670143,"objectID":"e800c23022d5e5e252d71103d1b8856e","permalink":"https://kangzhiqing.com/study/%E8%80%83%E7%A0%94/","publishdate":"2019-03-04T11:29:03+08:00","relpermalink":"/study/%E8%80%83%E7%A0%94/","section":"study","summary":"目标 Name Content 目标专业 计算机科学与技术 专业方向 WEB 开发 目标院校 浙江大学 目标分数 380 -- 购买书籍汇总 科目 书籍 数学 张宇高等数学18讲 李永乐线性代数辅助讲义 王","tags":[],"title":"考研","type":"study"},{"authors":null,"categories":[],"content":"  官网\u0026nbsp;\u0026nbsp;文档\nEntry Webpack的入口，通过入口文件，webpack开始搭建内部依赖网\n// webpack.config.js module.exports = { entry: './path/to/my/entry/file.js' };  Output 输出配置\nmodule.exports = { output: { filename: 'bundle.js', } };  Mode 主要是两种环境，开发环境（development）和生产环境（production），相应的环境，webpack会做出具体的优化方案。 （default：production）\nmodule.exports = { mode: 'production' // 'development' }  Loaders 加载器，用于加载资源，如scss文件或者将一些拓展语言（TypeScript,Scss）转换成合适的格式。 webpack内置可以处理的文件类型：JSON\nmodule.exports = { module: { rules: [ { test: /\\.css$/, use: 'css-loader' }, { test: /\\.ts$/, use: 'ts-loader' } ] } };   css-loader =\u0026gt; 处理.css文件 style-loader =\u0026gt; 通过\u0026lt;style\u0026gt;标签将css-loader内部样式注入到html中 Less-loader Sass-loader post-css-loader  Plugins 插件，webpack的支柱，webpack本身就是建立在类似的插件系统上的。 * banner-pulgin:\nWebpack-dev-server 安装依赖 npm install --save-dev webpack-dev-server  配置 module.export = { plugin:[ new webpack.HotModuleReplacementPlugin() // HMR功能插件 ] devServe:{ contentBase:'./public', // 本地服务器加载的页面所在目录 historyApiFallback:true, // true为不跳转，所有的跳转都会指向index.html inline:true // 为入口页面添加\u0026quot;热加载\u0026quot;功能 hot:true // 开启\u0026quot;热替换\u0026quot;（Hot Module Replacement HMR）功能 }, }  开启服务  直接在terminal中输入node_modules/.bin/webpack-dev-server,node_modeules下的.bin目录有许多执行文件可以直接运行\n 在package.json中的script对象中添加\u0026quot;server\u0026quot;:\u0026quot;webpack-dev-server\u0026quot;\n  \n在terminal中输入npm run server就可以了~\nBabel 编译Javascript的工具，使代码变得风骚，使用最新的javascript代码（ES6，ES7）并使用像react的JSX的扩展语言。 babel核心包 =\u0026gt; babel-core 解析ES6的包 =\u0026gt; babel-env-preset 解析JSX的包 =\u0026gt; babel-preset-react\nCSS模块化 利用css-loader和style-loader容易使全局样式遭到污染，css模块化通过将css的class名传递到具体的组件中，就可以有效的避免全局样式被污染\nmodules.export = { loader:{ rules:[ { test:/\\.css$/, use:[ { loader:\u0026quot;style-loader\u0026quot; }, { loader:\u0026quot;css-loader\u0026quot;, options:{ modules:true, localIdentName:'[name]__[local]--[hash:base64:5]' // css的类名格式 } ] } ] } }  ","date":1550212145,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1550212145,"objectID":"ff9f246211c7c78d9e90e0bab65fb5d8","permalink":"https://kangzhiqing.com/post/webpack/","publishdate":"2019-02-15T14:29:05+08:00","relpermalink":"/post/webpack/","section":"post","summary":"官网\u0026nbsp;\u0026nbsp;文档 Entry Webpack的入口，通过入口文件，webpack开始搭建内部依赖网 // webpack.config.js module.exports = { entry: './path/to/my/entry/file.js' }; Output 输出配置 module.exports = { output: { filename:","tags":["webpack"],"title":"Webpack","type":"post"},{"authors":null,"categories":[],"content":"官网\u0026nbsp;\u0026nbsp; 教程\u0026nbsp;\u0026nbsp; API\n\n  \n\n \n\n\n --  echarts.init(document.getElementById('bar')).setOption({ title:{ text:'柱状图' }, tooltip:{}, legend:{ data:['销量'] }, xAxis:{ data:[\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"] }, yAxis:{}, series: [{ type: 'bar', name: '销量', data: [5, 20, 36, 10, 10, 20] }] }); echarts.init(document.getElementById('pie')).setOption({ title:{ text:'饼状图' }, series: { name: '访问来源', type: 'pie', radius:'60%', data: [ {value:235, name:'视频广告'}, {value:274, name:'联盟广告'}, {value:310, name:'邮件营销'}, {value:335, name:'直接访问'}, {value:400, name:'搜索引擎'} ] } }); echarts.init(document.getElementById('line')).setOption({ title: {text: '直线图'}, tooltip: {}, toolbox: { // feature: { // dataView: {}, // saveAsImage: { // pixelRatio: 2 // }, // restore: {} // } }, xAxis: {}, yAxis: {}, series: [{ type: 'line', smooth: true, data: [[12, 5], [24, 20], [36, 36], [48, 10], [60, 10], [72, 20]] }] });  // 柱状图 echarts.init(document.getElementById('bar')).setOption({ title:{ text:'柱状图' }, tooltip:{}, legend:{ data:['销量'] }, xAxis:{ data:[\u0026quot;衬衫\u0026quot;,\u0026quot;羊毛衫\u0026quot;,\u0026quot;雪纺衫\u0026quot;,\u0026quot;裤子\u0026quot;,\u0026quot;高跟鞋\u0026quot;,\u0026quot;袜子\u0026quot;] }, yAxis:{}, series: [{ type: 'bar', name: '销量', data: [5, 20, 36, 10, 10, 20] }] }); // 饼状图 echarts.init(document.getElementById('pie')).setOption({ title:{ text:'饼状图' }, series: { name: '访问来源', type: 'pie', radius:'60%', data: [ {value:235, name:'视频广告'}, {value:274, name:'联盟广告'}, {value:310, name:'邮件营销'}, {value:335, name:'直接访问'}, {value:400, name:'搜索引擎'} ] } }); // 直线图 echarts.init(document.getElementById('line')).setOption({ title: {text: '直线图'}, tooltip: {}, toolbox: { // feature: { // dataView: {}, // saveAsImage: { // pixelRatio: 2 // }, // restore: {} // } }, xAxis: {}, yAxis: {}, series: [{ type: 'line', smooth: true, data: [[12, 5], [24, 20], [36, 36], [48, 10], [60, 10], [72, 20]] }] });  ","date":1550108556,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1550108556,"objectID":"911b65526fa40728aea9ae063180e2e7","permalink":"https://kangzhiqing.com/post/echarts/","publishdate":"2019-02-14T09:42:36+08:00","relpermalink":"/post/echarts/","section":"post","summary":"官网\u0026nbsp;\u0026nbsp; 教程\u0026nbsp;\u0026nbsp; API -- echarts.init(document.getElementById('bar')).setOption({ title:{ text:'柱状图' }, tooltip:{}, legend:{ data:['销量'] }, xAxis:{ data:[\"衬衫\",\"","tags":["Echarts","图表","数据"],"title":"ECharts","type":"post"},{"authors":null,"categories":null,"content":" Regular Expression\n正则表达式：匹配特殊字符或有特殊搭配原则的字符的最佳选择 创建方式  直接量 new RegExp();  // 直接量 var reg = /abc/ ; // new RegExp(); var reg = new RegExp(pattern. attribute); var reg = new RegExp(\u0026quot;abc\u0026quot;,\u0026quot;i\u0026quot;) var reg = new RegExp(/abc/i);  修饰符 /i ignoreCase 忽视大小写 /g global 全局匹配 /m multiline 多行匹配\n常用方法 str.match(reg) // 返回匹配成功的结果数组 str.search(reg) // 返回匹配到的位置，匹配不到返回-1 str.split(reg) str.replace(reg, newStr/function(){}) reg.test(str) // 匹配返回true，不匹配则返回false reg.exec() //  常用规则 \\w ==\u0026gt; [0-9A-z_] \\W ==\u0026gt; [^\\w] \\d ==\u0026gt; [0-9] \\D ==\u0026gt; [^\\d] \\s ==\u0026gt; [\\n\\f\\r\\t\\v] 空白字符 \\S ==\u0026gt; [^\\s] \\b ==\u0026gt; 单词边界 /\\bc/ 以c开头的单词 \\B ==\u0026gt; 非单词边界 . ==\u0026gt; [^\\r\\n] + ==\u0026gt; 匹配一次到无数次 {1, infinity} * ==\u0026gt; 匹配0次到无数次 {0, infinity} ? ==\u0026gt; 匹配0到1次 {0,1} ^ ==\u0026gt; 开头 $ ==\u0026gt; 结尾 | ==\u0026gt; 或 () ==\u0026gt; 子表达式 \\1 ==\u0026gt; 反向引用第一个子表达式一次 ()\\1 ==\u0026gt; 反向引用第一个子表达式一次 ()\\1\\1\\1 ==\u0026gt; 反向引用第一个子表达式两次  匹配原则：贪婪匹配原则（能匹配最多的） 如果要打破贪婪匹配就在量词后面加上？，则是非贪婪匹配\n正则表达式的属性 reg.global ==\u0026gt; 是否全局匹配 reg.ignoreCase ==\u0026gt; 是否忽略大小写 reg.multiline ==\u0026gt; 是否有换行匹配 reg.source ==\u0026gt; 返回正则表达式的文本 reg.lastIndex ==\u0026gt; 返回游标位置\n正向预查 正向断言 ?=/!= ==\u0026gt;断言表达式 var reg = /a(?=b)/g // 选择后面是b的a  Practice 1. 检验一个字符串首尾是否含有数字 var reg = /^\\d | \\d$/;  2. 将一个字符转换成小驼峰式写法 var str = \u0026quot;the-first-name\u0026quot;; var reg = /-(\\w)/g; str.replace(reg,function($,$1){ return $1.toUpperCase(); })  3. 字符串去重 var str = \u0026quot;aaaaaaaaaabbbbbbbbbbbbcccccccccc\u0026quot; var reg = /(\\w)\\1*/g; str.replace(reg,\u0026quot;$1\u0026quot;);  ","date":1548237113,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1548237113,"objectID":"bc8525c923206fc6b17fa768505b43bc","permalink":"https://kangzhiqing.com/post/regexp/","publishdate":"2019-01-23T17:51:53+08:00","relpermalink":"/post/regexp/","section":"post","summary":"Regular Expression 正则表达式：匹配特殊字符或有特殊搭配原则的字符的最佳选择 创建方式 直接量 new RegExp(); // 直接量 var reg = /abc/ ; // new RegExp(); var reg = new RegExp(pattern. attribute); var reg = new RegExp(\u0026quot;abc\u0026quot;,\u0026quot;i\u0026quot;) var reg = new RegExp(/abc/i); 修饰符","tags":["正则表达式"],"title":"RegExp","type":"post"},{"authors":null,"categories":null,"content":" 大致的一些计划\n非周日   Time Detail   7：00-7：30 起床、吃早饭   7：30-8：00 背英语单词  日常 刷一到两题LeetCode   其他时间 学习   17:00 运动（打羽毛球）   20：00 看有没有适合的课程学习，看看直播   22：30-23：00 读英文资料（不限）   23：00 洗漱、睡觉   周日   Time Detail   All FREE!!!   ","date":1547888161,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1547888161,"objectID":"60870bfb99bf58ef25c5695c680de004","permalink":"https://kangzhiqing.com/study/%E5%AF%92%E5%81%87%E8%AE%A1%E5%88%92/","publishdate":"2019-01-19T16:56:01+08:00","relpermalink":"/study/%E5%AF%92%E5%81%87%E8%AE%A1%E5%88%92/","section":"study","summary":"大致的一些计划 非周日 Time Detail 7：00-7：30 起床、吃早饭 7：30-8：00 背英语单词 日常 刷一到两题LeetCode 其他时间 学习 17:00 运动（打羽毛球","tags":null,"title":"寒假计划","type":"study"},{"authors":null,"categories":null,"content":" let 和 const ES6 新加了两种声明变量的方式，一个是 let，一个是 const。\n let 和 const 声明变量有自己的块级作用域（在 for 循环中用 let 声明的变量不会泄露到外部） let 和 const 声明变量在预编译的过程都不会进行变量提升 let 和 const 声明的变量不能再次声明，而 const 声明变量的时候必须同时赋值，并且不能再次赋值  { console.log(a); // ReferenceError:a is not undefined let a; } { let a = 1; let a = 2; // SyntaxError: Identifier 'a' has already been declared } { const a; // SyntaxError:Missing initializer in const declaration } { const a = 1; a = 2 // TypeError:Assignment to constant variable }  模板字面量  创建字符串不必再拼接了~  let a = { str: \u0026quot;模板字面量\u0026quot; }; console.log(\u0026quot;ES6\u0026quot; + a.str); // ES6 console.log(`ES6${a.str}`);   换行直接按下键盘的 Enter 就可以了  console.log(\u0026quot;ES6\\n模板字面量\u0026quot;); // ES6 console.log(`ES6 模板字面量`);  默认参数 function defalutPerson(person = \u0026quot;kzq\u0026quot;) { console.log(`The person is ${person}`); } defalutPerson(); defalutPerson(\u0026quot;HH\u0026quot;);  箭头函数  ES6 的箭头函数简化了函数的语法  var plus = function(a, b) { return a + b; }; // ES6箭头函数 var plus = (a, b) =\u0026gt; { return a + b; }; // 或者这样 var plus = (a, b) =\u0026gt; a + b;   箭头函数的 this 指向是固定的，即在箭头函数声明的时候就定义好了，继承来自外部最近的 this 指向  var x = 7; var obj = { x: 77, print: function() { console.log(this.x); } }; obj.print(); // obj调用的，则this指向obj，77 var obj = { x: 77, print: () =\u0026gt; { console.log(this.x); } }; obj.print(); // print是箭头函数，在声明的时候this就指向obj内部的this指向window，7 function test() { this.x = 7777; let print = function() { console.log(this); }; print(); } test(); // 全局调用this指向window，7 function test() { this.x = 7777; let print = () =\u0026gt; { console.log(this); }; print(); } test(); // 箭头函数print，print在定义的时候this就指向test，7777  解构赋值 var info = { name: \u0026quot;kzq\u0026quot;, age: 20, sex: \u0026quot;male\u0026quot; }; var { name, age } = info; console.log(name, age); var [, , lastNum] = [1, 2, 3];  扩展运算符(\u0026hellip;) // 合并数组 var person1 = [\u0026quot;kzq\u0026quot;, \u0026quot;lzj\u0026quot;, \u0026quot;hmy\u0026quot;, \u0026quot;dcb\u0026quot;]; var person2 = [\u0026quot;hh\u0026quot;, \u0026quot;hqy\u0026quot;, \u0026quot;xxbb\u0026quot;, \u0026quot;xx\u0026quot;]; var person = [...person1, ...person2]; // person2.push(...person) // 复制 var a = [1, 2, 3]; var oppA = [...a].reverse(); // 解构赋值 let { name1, name2, ...remainName } = { name1: \u0026quot;kzq\u0026quot;, name2: \u0026quot;hh\u0026quot;, name3: \u0026quot;wq\u0026quot;, name4: \u0026quot;xx\u0026quot; }; console.log(name1); // \u0026quot;kzq\u0026quot; console.log(name2); // \u0026quot;hh\u0026quot; console.log(remainName); // {name3:\u0026quot;wq\u0026quot;, name4:\u0026quot;xx\u0026quot;}  Object.assign 实现浅复制 var newObj = Object.assign(targetObj, sourceObj); // 把sourceObj复制给targetObj并返回targetObj  ","date":1546571018,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1546571018,"objectID":"5a6028d9a7312d5824c18b0eda244fb1","permalink":"https://kangzhiqing.com/post/es6/","publishdate":"2019-01-04T11:03:38+08:00","relpermalink":"/post/es6/","section":"post","summary":"let 和 const ES6 新加了两种声明变量的方式，一个是 let，一个是 const。 let 和 const 声明变量有自己的块级作用域（在 for 循环中用 let 声明的变量不会泄露到外部）","tags":["ES6"],"title":"ES6","type":"post"},{"authors":null,"categories":null,"content":"年末总结的开头就不感叹时光荏苒了（不过我还是要说一下时间过的是真的快呀！！！）  2018年的主要事迹如下= 报名计算机双学位 决定以后从事前端这个方向 学习  人呢，没有目标的时候是真的不知道自己在干嘛，我大二一年都是这样，平常正常上课，下课之后就基本没去碰生物方面的知识和技术，我认识到自己并不想从事生物方面的工作和研究，当初报考填写志愿也是比较匆忙，很随便。自己想想当初真的是很草率，高中的时候就没去了解相应的专业的信息，填写志愿的时候就瞎填。人呢，总是要做出选择，既然做出了选择就要面对相对应的事情。大二呢，也陆陆续续接触计算机语言python、爬虫方面的知识，发现自己对编程很感兴趣，给我的反馈也很多，也愿意花很多的时间去研究ta，所以到大二下看到信工学院的计算机科学与技术的双学位招新的消息，我就报了，打算以后从事互联网方面的工作。  暑假有两个月的时间，我没有选择去打暑假工，因为我太需要时间去学习，这两个月我基本都是在家里学习，7月份我学习了一种关系型数据库mysql还有scrapy爬虫，主要是想自己能够把一些信息爬下来并且存起来，但总感觉学习还是没有啥方向。到8月初，我室友叫我去学前端，暑假回来一起写写项目，我那时候正没有啥方向，刚好对前端也不是很了解，就去具体研究了一哈，我刚开始还以为JavaScript和Java有关系呢，我还问我室友要不要先学Java再学JavaScript，哈哈哈哈，现在想起来还是比较好笑的。那一个月就学习html，css，JavaScript，看网课还有一些文档，也决定以后就从事前端方向，月末模仿京东还有淘宝写了两个页面。  后面几个月就是陆陆续续进行前端的学习还有双学位的学习，虽然基本每个星期都比较忙，但感觉还是比较充实的。  关于学习上，这半年的学习，我发现原理是真的很重要，仅仅知道怎么用是远远不够，知其然也要知其所以然，还有就是不要为了解决问题而解决问题，很多东西容易忘，知道问题关键所在才能在后面遇到类似的问题也能解决。  关于游戏，还是和以前一样，英雄联盟和炉石传说，其他游戏基本没玩，很庆幸今年中国队终于夺冠了，大满贯耶，S8冠军，IG牛逼。今年没有去现场看比赛比较遗憾，现场的氛围是真的很high。联盟也打了5年了，真的久耶，从S4赛季到S8,今年打上钻石了，哈哈哈哈哈。炉石传说，别问，问就是蓝天白云，暴雪爸爸今年不怎么眷顾我，没怎么开出几张橙卡来。  最后，2018就要过去了，无论如何，感谢很多人，感谢自己，感谢2018。  再见，2018。你好，2019，加油~  ","date":1546244989,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1546244989,"objectID":"3e0fe0796ea3934617d9ca8a8868a976","permalink":"https://kangzhiqing.com/study/2018%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/","publishdate":"2018-12-31T16:29:49+08:00","relpermalink":"/study/2018%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/","section":"study","summary":"年末总结的开头就不感叹时光荏苒了（不过我还是要说一下时间过的是真的快呀！！！） 2018年的主要事迹如下= 报名计算机双学位 决定以后从事前端这个","tags":null,"title":"2018年末总结","type":"study"},{"authors":null,"categories":null,"content":" 感谢邱老师这一个学期的数据结构课的教导，让我了解到什么是数据结构和其重要性，以及相关的算法和实现。 这是一篇关于数据结构的复习。\n基本概念 1.程序 = 算法 + 数据结构 \u0026emsp; \u0026mdash;\u0026mdash; Nicklaus Wirth 一个程序就是通过具体的某种计算机语言将算法进行实现\n2.数据结构：相互之间存在一种或多种特定关系的数据元素的集合 具体什么是数据结构，包含下面三个部分=\u0026gt;\n 逻辑关系：线性关系、非线性关系 存储方式：顺序存储、链接存储、散列存储 （存储存的除了要存数据，还要存它们之间的关系，这一点是邱老师在刚上数据结构讲这些基本概念的时候特别强调的，我印象挺深的） 运算集合：查找和排序（插入=\u0026gt;直接法，二分法、交换=\u0026gt;冒泡排序，快速排序、选择=\u0026gt;堆排序）  3.算法：对特定问题求解步骤的一种描述。 一个算法还具有下列 5 个重要特性\n 有穷性\u0026emsp;一个算法必须在执行有穷步之后结束，但一个程序则可以无穷，比如说无限死循环 确定性\u0026emsp;算法的每一条指令必须有确切的含义 可行性\u0026emsp;一个算法是能行的 输入\u0026emsp;一个算法有零个或多个输入 输出\u0026emsp;一个算法有一个或多个输出  \n一个好的算法需要达到的目标\n 正确性 可读性 健壮性\u0026emsp;当输入数据非法时，算法也能做出反应或进行处理，即要可以处理一些特殊和极端情况 效率和低存储量需求\u0026emsp;时间复杂度低，算法执行时间短。满足需求的同时尽可能使用低的存储量消耗  4.时间复杂度：\u0026nbsp;算法中基本操作重复执行的次数是问题规模 n 的某个函数 f(n)，即 T(n) = O(f(n)) 5.空间复杂度：\u0026nbsp;算法所需存储空间的量度，即 S(n)=O(f(n))\n线性表 1.逻辑关系：线性关系/结构\n 存在唯一一个被称作\u0026rdquo;第一个\u0026rdquo;的数据元素 存在唯一一个被称作\u0026rdquo;最后一个\u0026rdquo;的数据元素 除第一个之外，集合中每个数据元素均只有一个前驱 除最后一个之外，集合中每个数据元素均只有一个后继  总的来说就是只有第一个元素有直接后继，没有前驱，只有最后一个元素有直接前驱，没有后继，在这两个元素之间的元素既有一个直接前驱也有一个直接后继\n\n2.存储方式和运算 （1）顺序存储：用一组地址连续的存储单元依此存储线性表中的数据元素\n// 在JavaScript中，数组就是一种隐式的存储关系 // 初始化数组 function listInit() { return new Array(); } // 插入=\u0026gt;第i-1个位置和第i个位置之间插入元素,i从1开始 function listInsert(list, i, data) { let len = list.length; if (i \u0026lt; 1 || i \u0026gt;= len + 1) { throw new Error(\u0026quot;i的位置有误\u0026quot;); } for (let j = len - 1; j \u0026gt;= i - 1; j--) { list[j + 1] = list[j]; } list[i - 1] = data; } // 删除=\u0026gt;删除第i个位置的元素 function listDelete(list, i) { let len = list.length; if (i \u0026lt; 1 || i \u0026gt; len) { throw new Error(\u0026quot;i的位置有误\u0026quot;); } for (let j = i - 1; j \u0026lt;= len - 1; j++) { list[j] = list[j + 1]; } // 切记不能用len--，因为是原始值，len改变并不会改变list.length list.length--; }  （2）链式存储：用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）\n 一个结点包含两个域，一个是数据域，一个是指针域，此链表的每个结点中只包含一个指针域，故又称为线性链表或单链表  // 单链表 function LinkListNode(data) { this.data = data; this.next = null; } var headNode = new LinkListNode(null); var len = 0; // 获取第i个元素 function getElem(i) { var p = headNode.next; var j = 1; while (p \u0026amp;\u0026amp; j \u0026lt; i) { p = p.next; j++; } return p ? p.data : null; } // 插入，在第i个位置之前插入元素e function linkListInsert(LinkListNode, i, e) { let newNode = new LinkListNode(e); var j = 1; p = headNode; if (i \u0026lt; 1 || i \u0026gt; len + 1) { return new Error(\u0026quot;i的范围有误\u0026quot;); } while (j \u0026lt;= i - 1 \u0026amp;\u0026amp; p.next) { p = p.next; j++; } newNode.next = p.next; p.next = newNode; len++; } // 删除，删除第i个位置的结点 function linkListDelete(i) { var j = 1; pre = headNode; p = pre.next; while (j \u0026lt; i \u0026amp;\u0026amp; p.next) { pre = p; p = pre.next; j++; } if (j == i) { return new Error(\u0026quot;超出链表范围\u0026quot;); } pre.next = p.next; len--; }   双向链表：结点有两个指针域，其一指向直接后继，另一指向直接前驱  // 双链表 function DuListNode(data, prior, next) { this.data = data || null; this.prior = prior || null; this.next = next || null; } var headNode = new DuListNode(); // 获取第i个位置的结点（i从1开始） function getDuList(i) { var p = headNode; var j = 1; while (j \u0026lt;= i \u0026amp;\u0026amp; p.next) { p = p.next; j++; } return p.data ? p.data : null; } // 获取表长 function getDuListLen() { var j = 0; var p = headNode; while (p.next) { p = p.next; j++; } return j; } // 在带头结点的双链表的第i个位置之前插入元素e function insertDuList(i, e) { if (i \u0026lt; 1 || i \u0026gt; getDuListLen() + 1) { return new Error( \u0026quot;i的范围应该不小于1且不大于表长加1,即len\u0026gt;=1 \u0026amp;\u0026amp; len\u0026lt;=\u0026quot; + (getDuListLen() + 1) ); } var j = 1; var p = headNode; var newNode = new DuListNode(e); while (p.next \u0026amp;\u0026amp; j \u0026lt; i) { p = p.next; j++; } if (p.next) { newNode.next = p.next; p.next.prior = newNode; p.next = newNode; newNode.prior = p; } else { p.next = newNode; newNode.prior = p; } } // 删除第i个位置的结点 function delDuListNode(i) { var j = 1; var p = headNode; if (getDuList(i) !== null) { while (j \u0026lt;= i) { p = p.next; j++; } } else { return new Error(\u0026quot;不存在第\u0026quot; + i + \u0026quot;个结点\u0026quot;); } p.prior.next = p.next; } // 打印每个结点(包含头结点) function printDuList() { p = headNode; while (p || (p \u0026amp;\u0026amp; !p.prior \u0026amp;\u0026amp; !p.next)) { console.log(p); p = p.next; } }   循环链表：表中最后一个结点的指针域指向头结点，整个链表形成一个环，从表中任一结点出发均可找到表中其他结点 其操作和单链表和双链表的操作差不多，只不过算法的循环条件变成了 p.next 是否为头指针或者 p 是否为头指针  栈和队列 栈 1.\u0026nbsp;逻辑结构：运算受限的线性表（限定仅在表尾进行插入或删除操作的线性表）\n FILO（First In Last Out）先进后出 LIFO（Last In First Out）后进先出 栈顶：表尾端 栈底：表头端  2.\u0026nbsp;存储和运算:\n 顺序栈  // 栈 function Stack() { // 数据 this.data = []; // 栈顶 this.top = 0; // 栈底 this.base = 0; // 入栈 this.entryStack = entryStack; // 出栈 this.exitStack = exitStack; // 返回栈顶元素 this.getTop = getTop; // 长度 this.length = getLength; } function entryStack(e) { this.data[this.top++] = e; } function exitStack() { return this.data[--this.top]; } function getTop() { return this.data[top - 1]; } function getLength() { return this.top - this.base; } // 利用栈进行数制转换 var s = new Stack(); var n = prompt(\u0026quot;请输入数字\u0026quot;); var d = prompt(\u0026quot;请输入要转换的进制\u0026quot;); console.log(n, d); while (n) { s.entryStack(n % d); n = parseInt(n / d); } while (s.length()) { console.log(s.exitStack()); } // 利用栈计算一个数的阶乘 var s = new Stack(); var n = prompt(\u0026quot;请输入你要计算的数：\u0026quot;); var result = 1; while (n \u0026gt; 1) { s.entryStack(n--); } while (s.length()) { result *= s.exitStack(); } console.log(result);   链栈  \n栈的链式表示 队列 1.逻辑结构\n FIFO（first in first out） LILO（last in last out） 一端进行插入，另一端删除元素 允许插入的一端叫做队尾（rear） 允许删除的一端叫做队头 （front）  2.存储和运算\n（1） 顺序存储\n// 队列 function Queue() { // 数据 this.data = []; // 队头 this.front = 0; // 队尾 this.rear = 0; // 获取队头 this.getFront = getFront; // 获取队尾元素 this.getRear = getRear; // 入队 this.entryQueue = entryQueue; // 出队 this.exitQueue = exitQueue; // 获取队列长度 this.length = getLength; // 队列是否为空 this.isQueueEmpty = isQueueEmpty; } function getFront() { return this.data[this.front]; } function getRear() { return this.data[this.rear - 1]; } function entryQueue(e) { this.data[this.rear++] = e; } function exitQueue() { return this.data[this.front++]; } function getLength() { return this.rear - this.front; } function isQueueEmpty() { return this.front == this.rear ? true : false; }  （2） 链式存储\n// 单链队列（不引入头结点） function linkQueue() { this.front = null; this.rear = null; this.length = 0; } linkQueue.prototype.qNode = function(e) { this.data = e; this.next = null; }; // 判断队是否为空 linkQueue.prototype.isQueueEmpty = function() { return this.front == this.rear \u0026amp;\u0026amp; this.front == null ? true : false; }; // 入队 linkQueue.prototype.entryQueue = function(e) { var newNode = new this.qNode(e); if (this.length == 0) { this.front = this.rear = newNode; } else { this.rear.next = newNode; this.rear = newNode; } this.length++; return true; }; // 出队 linkQueue.prototype.exitQueue = function() { if (!this.isQueueEmpty()) { var p = this.front; this.front = this.front.next; // 当队列最后一个元素出队后，队列的尾指针也丢失，则需要从新复制 if (this.rear == p) { this.rear = this.front; } this.length--; return p; } else { return new Error(\u0026quot;当前队列为空\u0026quot;); } }; // 打印当前队列 linkQueue.prototype.printQueue = function() { var str = \u0026quot;\u0026quot;; var p = this.front; while (p) { str += p.data + \u0026quot; \u0026quot;; p = p.next; } console.log(\u0026quot;当前队列为：\u0026quot; + str); };  （3）循环存储 设顺序存储队列用一维数组 q[m]表示，其中 m 为队列中元素个数，队列中元素在向量中的下标从 0 到 m-1。 在出队的时候，front 头指针向右移动，如果队尾指针指向 m-1，队列中仍有空闲单元，所以队列不是真的满了， 这时候入队操作，就会出现假溢现象。为了避免多余的空闲单元浪费（假溢出现），则引入循环队列，仅仅用 front==rear 无法判断队列空间是空还是满，有两种处理方法，一种是另外设置一个标志位来区别队空和队满的区别，另一种是少用一个元素空间，约定以“头指针在队尾指针的下一位置上”作为队列呈“满”状态的标志，这里是第二种\n// 循环队列 function CQueue(maxLength) { this.maxLength = maxLength; this.data = new Array(maxLength); // 初始化的时候头指针和尾指针都为0，每入队，rear指针加一，指向下一个位置 this.front = 0; this.rear = 0; this.length = 0; // 获取队列长度 this.getLength = function() { return (this.rear - this.front + this.maxLength) % this.maxLength; }; // 入队 this.entryQueue = function(e) { if ((this.rear + 1) % this.maxLength == this.front) { return new Error(\u0026quot;队列已满\u0026quot;); } this.data[this.rear] = e; this.rear = (this.rear + 1) % this.maxLength; this.length++; }; // 出队 this.exitQueue = function() { if (this.front == this.rear) { return new Error(\u0026quot;队列为空\u0026quot;); } var p = this.data[this.front]; this.front = (this.front + 1) % this.maxLength; return p; }; // 打印当前队列元素 this.printQueue = function() { var str = \u0026quot;\u0026quot;; var p = this.front; while (p % this.maxLength \u0026lt; this.rear) { str += this.data[p] + \u0026quot; \u0026quot;; p = (p + 1) % this.maxLength; } console.log(str); }; }  树和二叉树 1.逻辑结构：\n 树：n（n \u0026gt; 0）个节点的有限集 二叉数：每个结点的度最多为二（最多有两个子树）  2.存储和运算（二叉树）\n 顺序存储：用一组地址连续的存储单元依次自上而下，自左向右存储完全二叉数的结点元素，以‘0’表示不存在此结点。 链式存储  // 创建二叉树（这里实现二叉排序树） // 二叉排序树（Binary Sort Tree）BST：左子树上结点的值小于ta的根结点的值，而右子树上结点的值大于ta的根结点的值，没有键值相等的节点 function BinaryTree() { // 根节点 this.root = null; // 节点 this.Node = function(data) { this.data = data; // 左指针 this.left = null; // 右指针 this.right = null; }; // 插入 this.insert = function(data) { let newNode = new this.Node(data); if (this.root === null) { this.root = newNode; } else { this.insertNode(this.root, newNode); } }; this.insertNode = function(root, newNode) { if (newNode.data \u0026lt; root.data) { if (root.left === null) { root.left = newNode; } else { this.insertNode(root.left, newNode); } } else { if (root.right === null) { root.right = newNode; } else { this.insertNode(root.right, newNode); } } }; // 先序遍历 this.preOrderTraversal = function(callback) { this.preOrderTraversalNode(this.root, callback); }; this.preOrderTraversalNode = function(node, callback) { if (node !== null) { callback(node.data); this.preOrderTraversalNode(node.left, callback); this.preOrderTraversalNode(node.right, callback); } }; // 中序遍历（中序遍历二叉排序树得到的就是按从小到大的顺序访问所有节点） this.inOrderTraversal = function(callback) { this.inOrderTraversalNode(this.root, callback); }; this.inOrderTraversalNode = function(node, callback) { if (node !== null) { this.inOrderTraversalNode(node.left, callback); callback(node.data); this.inOrderTraversalNode(node.right, callback); } }; // 后序遍历 this.postOrderTraversal = function(callback) { this.postOrderTraversalNode(this.root, callback); }; this.postOrderTraversalNode = function(node, callback) { if (node !== null) { this.postOrderTraversalNode(node.left, callback); this.postOrderTraversalNode(node.right, callback); callback(node.data); } }; this.printNode = function(value) { console.log(value); }; // 获取BST中的最小值 this.minData = function(){ let p = this.root; while(p \u0026amp;\u0026amp; p.left){ p = p.left; } return p.data; } // 获取BST中的最大值 this.maxData = function(){ let p = this.root; while(p \u0026amp;\u0026amp; p.right){ p = p.right; } return p.data; } // 查询一个节点 this.findNode = function(key,node=this.root){ if(node !== null){ if(key \u0026lt; node.key){ this.findNode(key,node.left); }else if(key \u0026gt; node.key){ this.findNode(key, node.right); }else{ return node; } }else{ return null; } } // 移除一个节点 this.removeNode = function(key){ let p = root; while(p.data) if(node==null){ return null; } } }  3.二叉树的性质\n 在二叉数的第 i 层上至多有 2^(i-1)个结点（i\u0026gt;=1） 深度（树中结点 最大的层次）为 k 的二叉树至多有 2^k-1 个结点 2^0+2^1+\u0026hellip;+2^k-1 = 2^0(1-2^k)/1-2 = 2^k - 1 对任何一颗二叉数 T，如果度为 0 的结点树为 n0，度为 2 的结点数为 n2，则 n2 = n0 + 1 满二叉树：一颗深度为 k 且有 2^k-1 个结点的二叉数称为满二叉树 完全二叉树：深度为 k，有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应  ","date":1545787211,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1545787211,"objectID":"c7b115875cf971219a008c59f3845f7a","permalink":"https://kangzhiqing.com/post/datastructure/","publishdate":"2018-12-26T09:20:11+08:00","relpermalink":"/post/datastructure/","section":"post","summary":"感谢邱老师这一个学期的数据结构课的教导，让我了解到什么是数据结构和其重要性，以及相关的算法和实现。 这是一篇关于数据结构的复习。 基本概念 1.程","tags":["dataStructure","structure"],"title":"数据结构","type":"post"},{"authors":null,"categories":null,"content":"和林语堂先生在《苏东坡传》开篇写的那样，我写这篇读后感并没有什么特别的理由，只是以此为乐而已，且此篇读后感和以往写的不同，算是一篇读书笔记吧，边读边写，有所感悟便写下来。也是希望自己能在这个忙碌和大多数事情追求快的时代偶尔能够慢下来~ 故乡飘已远，往意浩无边。这句诗描绘的东坡二十左右一家进京任职的时候他的心境，故乡虽已远去，但去意浩瀚无边，此时的他满腹才华、自信以及对于仕途的向往和憧憬。在二十岁出头这个年纪，东坡可以说是文名日胜。 在描写苏夫人警惕东坡要提防那些过于坦白直率的泛泛之交，提放丈夫认为“天下无坏人”的大前提之下所照顾的那些朋友。林语堂先生觉得苏夫人的智慧是自“君子之交淡如水”得来的，水没有刺激的味道，但是人永远不会对之生厌。真诚的友谊永远不会特别表白的，真正的好朋友彼此不必通信，因为既是对彼此的友情信而不疑，谁也不需要写什么。一年分别后，再度相遇，友情如故。我觉得很多我和我高中的两个朋友之间就是如此，高中之后，大家各自分别，去了不同的学校上学，虽然在学校这些时间我们之间聊的天不多，但每每寒暑假回家，我们都会有聚一聚，友情如故，大家一起聊聊大学的一些事和感受,我觉得这样挺好的。 讲真，王安石变法那一段关于政治和经济局势的部分，看不太懂.... ","date":1544752017,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1544752017,"objectID":"c8dcd9ae4a8f815c86da39fc398539a3","permalink":"https://kangzhiqing.com/life/dongpo/","publishdate":"2018-12-14T09:46:57+08:00","relpermalink":"/life/dongpo/","section":"life","summary":"和林语堂先生在《苏东坡传》开篇写的那样，我写这篇读后感并没有什么特别的理由，只是以此为乐而已，且此篇读后感和以往写的不同，算是一篇读书笔记吧","tags":null,"title":"林语堂《苏东坡传》读后感","type":"life"},{"authors":null,"categories":null,"content":" 在学习node的时候，进行连接数据库相关操作，于是就学习了一下mongodb非关系型数据库。 mongodb操作的都是对象\n基本命令汇总 show dbs 显示所有的数据库 show tables 显示当前数据库下的所有表 db 显示当前数据库 use mydb 切换到mydb数据库，如果没有则创建mydb数据库 db.stu.insert({}) 向stu表中插入数据，如果没有stu则创建一个stu表 db.stu.find() 显示stu表下的所有数据 db.stu.find({条件1},{条件2}) 查找满足条件1且条件2的数据 db.stu.find({$or:[{条件1},{条件2}]}) 查找满足条件1或条件2的数据 db.stu.find({age:{$gte:10,$lte:20}}) 查询stu表中age大于等于10并且小于等于20的数据  ","date":1544515609,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1544515609,"objectID":"9e5df23d090bd250c683f6ed8f290730","permalink":"https://kangzhiqing.com/post/mongodb/","publishdate":"2018-12-11T16:06:49+08:00","relpermalink":"/post/mongodb/","section":"post","summary":"在学习node的时候，进行连接数据库相关操作，于是就学习了一下mongodb非关系型数据库。 mongodb操作的都是对象 基本命令汇总 show dbs 显示","tags":["数据库","非关系型","MongoDb"],"title":"Mongodb","type":"post"},{"authors":null,"categories":null,"content":" 之所以用别人造好的轮子，就是觉得自己的设计水平很差，脑子也没有很多的样式储备，写出来的样式有点丑，于是乎就想用一用类似BootStrap、uiket等轮子库，借鉴一下。这里就先学习了一下element-ui，，看！别人的轮子又大圆~\n基本介绍 Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库 现在是vue3.0，估计一段时间之后就会变成3.0了，相应的改动也会更新\nVue-cli@3.0使用element-ui 作为一个插件添加到vue-cli中\nvue create el cd el vue add element  安装element插件过程中会有交互，是全部导入，还是按需求导入，我是选择按需求导入，这样比较方便，也比较轻。 成功之后就可以看到你的vue-cli初始页面就会有一个element-button\nelement.js import Vue from 'vue' import { Button } from 'element-ui' import 'element-ui/lib/theme-chalk/index.css' Vue.use(Button)  tip：一定要导入对应你需要的css样式，这样才有用,index.css是theme-chalk下所有的css入口文件，如果只想单独使用某个css，找到那个css导入就好了 选择你需要的轮子 官网有很详细的介绍和样式预览，选择需要的，然后使用就好了，对于很好的样式可以看一看具体css怎么实现的，增加一些自己写css的能力\nFAQ  vue使用element-ui的el-input监听不了回车事件解决 在后面加个native @keydown.enter.native  ","date":1543931267,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543931267,"objectID":"8cbd5f9e87a1aaf4bcab88694f99f0e0","permalink":"https://kangzhiqing.com/post/element-ui/","publishdate":"2018-12-04T21:47:47+08:00","relpermalink":"/post/element-ui/","section":"post","summary":"之所以用别人造好的轮子，就是觉得自己的设计水平很差，脑子也没有很多的样式储备，写出来的样式有点丑，于是乎就想用一用类似BootStrap、u","tags":["element-ui","轮子库"],"title":"Element Ui","type":"post"},{"authors":null,"categories":null,"content":" 坑 在使用axios拦截器的时候，在vue-router的钩子函数created是不会触发的\nscroll 在写websocket网页版聊天时，有个需求时每次发消息，scroll都要定位在最下面，刚开始我是监听一个data里message数据的变化，每次有消息的时候，元素的scrollTop=元素的scrollHeight，但每次都是滚动条都定位在最底下的上一条消息上，因为每有一个消息，我就push到message的数组里面，然后页面自动渲染，也就是在最后一条消息渲染完成前就完成了滚动条的移动，所以导致每次都差一条消息的位置。解决办法就是监听dom的变化， 使用this.$nextTick()，dom变化后再进行滚动条的移动\n只能点击一次事件 v-click.once=\u0026ldquo;clickOnce\u0026rdquo;\n","date":1543918874,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543918874,"objectID":"8af62db9ab845536c48c82bf65cd894a","permalink":"https://kangzhiqing.com/post/vue/","publishdate":"2018-12-04T18:21:14+08:00","relpermalink":"/post/vue/","section":"post","summary":"坑 在使用axios拦截器的时候，在vue-router的钩子函数created是不会触发的 scroll 在写websocket网页版聊天时，有个需求时每","tags":["vue"],"title":"Vue","type":"post"},{"authors":null,"categories":null,"content":" 记录学习docker的过程\n特性 标准化 加速开发和构建流程，方便测试。容器可以在开发环境构建，轻松的提交到测试环境，并最终进入生产环境\ndocker核心组件  docker客户端和服务器（C/S）：docker引擎 docker镜像 仓库Registry docker容器  安装 按照官网给的步骤一步一步来就好了 https://docs.docker.com/install/\n启动 $ systemctl start docker  运行一个容器 $ docker run -i -t centos /bin/bash  -i 开启标准输入(STDIN) -t 分配伪tty终端 设置了这两个参数就创建了一个我们可以交互的容器\n附着到正在运行的容器 $ docker attach containerId/Name  删除容器 删除一个容器 $ docker rm containerId/Name 删除所有容器(-q是只显示容器id) $ docker rm `docker ps -a -q`  镜像 拉取镜像\n$ docker pull imageName:version  删除镜像\n$ docker rmi imageName:version/id  查看镜像详细信息\n$ docker inspect repositoryName/imageId  将镜像推送到Docker Hub 登录\n$ docker login Username:~ Password:~  推送\n$ docker push Username/~:tag push到远程仓库的镜像名必须是用户名开头的镜像，如果不是会被拒绝，改下镜像名字就好了 $ docker tag imageId Username/~:tag  创建镜像 commit命令创建镜像\n$ docker commit containerId/Name respositoryPath  Dockerfile创建镜像\n$ mkdir buildEnv $ cd buildEnv $ touch Dockerfile $ vim Dockerfile # Dockerfile # 指定基础镜像(base image) FROM ubuntu:latest # 申明作者以及邮箱 MAINTAINER Name \u0026quot;Email\u0026quot; # 执行RUN指令 RUN apt-get update \u0026amp;\u0026amp; apt-get install -y nginx RUN echo 'hello world' \u0026gt;/usr/share/nginx/html/index.html # 暴露端口 EXPOSE 80 $ docker build -t=\u0026quot;kzq/nginx\u0026quot; . 启动镜像 $ docker run -d -p 80 \u0026quot;kzq/nginx\u0026quot; nginx -g \u0026quot;daemon off;\u0026quot; // -d以分离（detached）的方式在后台运行 -p公开端口给宿主机  自动化工具docker-compose Compose is a tool for defining and running multi-container Docker applications Compose是一个用于定义和运行多容器Docker应用程序的工具\n 安装 话不多说，官网文档大法好 https://docs.docker.com/compose/install/ 三步走 (1)创建Dockerfile搭建环境 (2)创建docker-compose.yml配置服务 (3)运行docker-compose up docker-compose.yml格式(注意空格)  version: '3' services: web: ports: - \u0026quot;5000:5000\u0026quot; volumes: - .:/code - logvolume01:/var/log links: - redis redis: image: redis  nginx配置 # 用户名 user nginx; # 工作进程数 worker_processes auto; # 错误日志 error_log /var/log/nginx/error.log; # 进程管理 pid /run/nginx.pid; # Load dynamic modules. 加载动态模块 include /usr/share/nginx/modules/*.conf; # events模块，处理连接的设置 events { # 每个进程的最大连接数 worker_connections 1024; } # http服务 http { # 日志格式 log_format main '$remote_addr - $remote_user [$time_local] \u0026quot;$request\u0026quot; ' '$status $body_bytes_sent \u0026quot;$http_referer\u0026quot; ' '\u0026quot;$http_user_agent\u0026quot; \u0026quot;$http_x_forwarded_for\u0026quot;'; # 访问日志 access_log /var/log/nginx/access.log main; # sendfile传输文件系统 # 传统方法：硬盘-\u0026gt;内核缓冲区-\u0026gt;用户缓冲区-\u0026gt;内核socket缓冲区-\u0026gt;协议引擎 # sendfile方法:硬盘-\u0026gt;内核缓冲区-\u0026gt;内核socket缓存区-\u0026gt;协议引擎 # sendfile系统调用DMA引擎直接将文件数据从内核缓存区拷贝到内核socket缓冲区，提高了性能 sendfile on; tcp_nopush on; tcp_nodelay on; # 连接超时时间 keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; server { listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } }  ","date":1543479934,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543479934,"objectID":"8b987a11764fa95fae8b94d2e5213018","permalink":"https://kangzhiqing.com/post/docker/","publishdate":"2018-11-29T16:25:34+08:00","relpermalink":"/post/docker/","section":"post","summary":"记录学习docker的过程 特性 标准化 加速开发和构建流程，方便测试。容器可以在开发环境构建，轻松的提交到测试环境，并最终进入生产环境 docke","tags":["docker"],"title":"Docker","type":"post"},{"authors":null,"categories":null,"content":"需要写一些关于C的实验报告，老师给的VC++6.0感觉很难用(字体小而且难看)，于是乎就想用我经常用的vscode编辑器来写C，上网百度了一些教程，搞了半天都没怎么搞懂里面的配置，于是自己就捣鼓了一哈。\n 在vscode下载C/C++(Microsoft)扩展 下载编译器tdm-gcc(windows),其他编译器具体请看对应的官网，我觉得这个比较容易装就装了这个。 安装成功会自动到将tdm-gcc的bin路径加入到windows的path变量中，如果没有则自己手动添加一下  基本上做完上面两步就可以了 直接在终端输入gcc file.c -o file.exe就编译好了。 还有一种简单的方法就是在VScode中安装一个扩展插件\u0026ndash;Code Runner,这是一个可以运行C，C++，java，JS，PHP，Python的一个插件,安装好了重新加载一下就会看到在VScode右边出现一个运行的按钮,不过默认是在输出下运行，不过输出是一个只读编辑器,所以如果有scanf需要输入的话就不能做了。这时候改下Code Runner的配置，使它运行在Terminal。 文件\u0026ndash;\u0026gt;首选项\u0026ndash;\u0026gt;设置\u0026ndash;\u0026gt;用户设置\u0026ndash;\u0026gt;扩展\u0026ndash;\u0026gt;Code Runner Configuation\u0026ndash;\u0026gt;勾选✔Run in Terminal 还有一个问题就是运行C的时候中文在Terminal中使会乱码的，这是因为cmd自身编码的问题, 解决办法是终端或者在CMD.exe中进入到当前文件目录下输入chcp(CHCP是一个计算机指令，能够显示或设置活动代码页编号), 默认应该是936简体中文，所以需要改为utf-8，utf-8代码页编号是65001，输入chcp 65001就好了\n","date":1543315166,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543315166,"objectID":"229bd06f5a62231c6be9baa43a2587c8","permalink":"https://kangzhiqing.com/post/vscode_c/","publishdate":"2018-11-27T18:39:26+08:00","relpermalink":"/post/vscode_c/","section":"post","summary":"需要写一些关于C的实验报告，老师给的VC++6.0感觉很难用(字体小而且难看)，于是乎就想用我经常用的vscode编辑器来写C，上网百度了一","tags":["vscode","C环境"],"title":"VScode配置C环境","type":"post"},{"authors":null,"categories":null,"content":" 开此篇记录下学习node的过程和一些笔记\nNode.js的一些特性  基于Chrome的V8引擎 事件驱动、非堵塞、单线程 Node.js是一个非阻塞的系统，当调用一些需要阻塞的等待或者事件，node会采用回调函数替代闲置等待，即事件驱动。就像我们在学校经常吃饭点餐的情况，点完餐之后店家会给个小票，上面有这此点餐的号码，到时候菜做好了就会叫号，这个号码相当于回调号码，这样就提高了效率，继续为下一个客人服务。 串行IO和并行IO，类似于同步和异步，前者的运行顺序是固定的，后者任何一个IO操作返回时间都是不确定的，如果IO操作有关联的话就要使用串行IO。按顺序的串行请求，无序的并行的请求  模块加载  require导入 exports导出  核心模块 files // ---------files--------- // Node.js利用流的方式来处理文件 // 引入模块 var fs = require('fs'); // 1.写文件，当前路径下没有就创建一个，如果存在就覆盖 fs.writeFile('./test.txt', '异步写入一些数据', 'utf8', function(err){ if(err){ console.log('写入失败') throw err }else{ console.log('写入成功') } }) fs.writeFileSync('./test.txt','同步写入一些数据','utf8') // 2.读文件，如果不加编码类型，则data返回的就是一个buffer缓冲区，里面存有二进制数据 fs.readFile('./test.txt','utf8',function(err, data){ console.log(data) }) // 3.追加文件，如果没有则创建一个 fs.appendFileSync('./log.txt', '同步追加，写入时间：'+new Date().toLocaleString()+'\\n') fs.appendFile('./log.txt','异步追加，写入时间：'+new Date().toLocaleString()+'\\n',function(err){ if(err){ console.log('添加失败') }else{ console.log('添加成功') } }) // 4.监听文件，文件只要修改了就会执行回调函数 fs.watchFile('./log.txt', function(cuur,prev) { console.log(prev); }) // 5.判断文件是否存在，存在返回true，不存在返回false var res = fs.existsSync('/a'); console.log(res); fs.exists('./a',function(res){ if(res){ console.log('文件存在') }else{ console.log('文件不存在') } })  http // --------------http----------------- var http = require('http'); var fs = require('fs') // 创建服务 var myServer = http.createServer(function(req, res){ var reqUrl = req.url=='/'?'./html/index.html':'./html'+req.url; if(fs.existsSync(reqUrl)){ var html = fs.readFileSync(reqUrl); res.write(html); }else{ var errPage = fs.readFileSync('./html/404.html'); res.write(errPage); } res.end(); }) // 监听 myServer.listen('1313', function(err){ if (err){ console.log('监听失败') throw err }else{ console.log('服务器已经开启，端口号为：1313') } })  path // --------path------------ var path = require('path'); // 当前文件夹路径 console.log(__dirname) // 当前文件路径 console.log(__filename) // 路径的字符串拼接 var url = path.join('html', 'index.html'); console.log(url)  url  url.parse(urlStr)：返回一个url对象 url.format(urlObj)：传入一个url对象，返回一个完整的url地址 url.resolve(from,to)：拼接两个对象或者是字符串url  dns  dns.resolve()：将一个域名解析为指定类型的数组 dns.lookup()：返回第一个被发现的IPv4或者IPv6的地址 dns.reverse()  Express框架 // --------express框架---------- var express = require('express'); var path = require('path'); // 实例化对象 var app = express(); // 路由传参 app.get('/student/:id', function(req,res){ var id = req.params.id; console.log(id); }) // 客户端所有请求 app.all('/all', function(req, res){ res.send('所有的请求都接受了'); }) // 客户端get请求 app.get('/account', function(req, res){ res.status(200).json({ code:0, data:{ name:'kzq', age:20 }, message:'ok' }) }) // 设置访问页面(默认index.html) app.use(express.static(path.join(__dirname,'html'))) app.use('/hello', function(req, res){ res.status(200).sendFile(path.join(__dirname, 'html', 'hello.html')) }) app.use('*', function(req, res){ res.status(404).sendFile(path.join(__dirname, 'html', '404.html')) }) // 监听端口 app.listen(3000, function(err){ if(err){ console.log('监听失败'); throw err; }else{ console.log('express搭建的服务器已开启，端口号是3000') } })  文件系统 优点与缺点  优点/应用场景：数据密集型实时（比如聊天系统、微博之类的） 不适合压缩/解压缩，加/解密，模板渲染  ","date":1543309499,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543309499,"objectID":"1f8c22bfe1e373ca565f9a45b1fa3b13","permalink":"https://kangzhiqing.com/post/node/","publishdate":"2018-11-27T17:04:59+08:00","relpermalink":"/post/node/","section":"post","summary":"开此篇记录下学习node的过程和一些笔记 Node.js的一些特性 基于Chrome的V8引擎 事件驱动、非堵塞、单线程 Node.js是一个非阻塞","tags":["Node"],"title":"Node","type":"post"},{"authors":null,"categories":null,"content":" 2018年7月之前 暑假之前我就一直陆陆续续的接触后端的python语言，爬虫相关的知识\n2018年7月 mysql数据库，scrapy爬虫\n2018年8月 正式进入前端的学习。从基础的HTML，CSS，JavaScript出发，在8月月底模仿京东和淘宝写了两个没有数据交互的页面，只能说有些僵硬，没有后台的数据，那些二级菜单的商品数据都是自己写的，挺多的。\n2018年9月 开始学习使用vue框架，用vue框架和室友一起合作写了一个监控系统。\n2018年10月 主要都在看一些书，巩固一些JavaScript的知识\n2018年11月 要做一个我们寝室的照片墙，学习了three.js 学three.js的时候，遇到一个坑就是一定要注意camera的位置，因为所有屏幕的图像都是从camrea中看到的，如果camera的位置设置的不好，物体就很难看到，屏幕就会是一团黑色的，我刚开始以为是哪里出了问题，找了半天没找出问题，后面一看camera的position有问题，导致图像看不到了。包括controls的minDistance也要注意不要太大，太大会导致图像只能到一小点，误以为没有，其实是该参数设置太大了\n2018年12月 这个月呢，本专业的考试提前考了，所以前半个月都在准备期末考试，后面用vue写了一个圣诞活动的手机端页面，天使和国王，实现愿望的一个简单的活动页面，挺开心的，班上有一半多都参加了，嘻嘻，第一次自己写的页面有这么多人看，还是比较开心的，不过写这个页面也发现自己对手机端的适配的问题还不是很了解，后期还是要好好学习一下。 tips:2018年度总结我单独写了一篇 =\u0026gt; 2018年度总结\n2019年1月 准备期末考试\n2019年2月 入了个webpack的门，还有很多训练没做\n决定考研=\u0026gt; 开了一篇专门记录考研的博客 传送门\n","date":1542759603,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1542759603,"objectID":"305b221ee64ece57729dbbc5a0d04d98","permalink":"https://kangzhiqing.com/study/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/","publishdate":"2018-11-21T08:20:03+08:00","relpermalink":"/study/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/","section":"study","summary":"2018年7月之前 暑假之前我就一直陆陆续续的接触后端的python语言，爬虫相关的知识 2018年7月 mysql数据库，scrapy爬虫 201","tags":null,"title":"学习过程记录","type":"study"},{"authors":null,"categories":null,"content":" tween.js - http://github.com/sole/tween.js JavaScript tweening engine for easy animations, incorporating optimised Robert Penner\u0026rsquo;s equations. JavaScript补间引擎，可轻松制作动画，并采用优化的Robert Penner方程。\n1.基本用法(Usage) // 开始位置 var InitPosition = {x:100,y:0}; // 目标位置 var targetPosition = {x:200,y:0}; // 创建一个开始位置的tween var tween = new TWEEN.Tween(Initposition); // 告诉tween需要变换到的位置和时间 tween.to({targetPositon},time); // 开始这个动画 tween.start(); // 为了使动画尽可能平滑,可以在每次循环的时候更新tween animate(); function animate() { requestAnimationFrame(animate); //... TWEEN.update(); //... } // 整个变换过程中是不能看到位置的变换的,如果需要可以执行以下代码 tween.onUpdate(function() { console.log(this) })  ","date":1542511368,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1542511368,"objectID":"d1af2ec59127379bfe8167c9b562983b","permalink":"https://kangzhiqing.com/post/tweenjs/","publishdate":"2018-11-18T11:22:48+08:00","relpermalink":"/post/tweenjs/","section":"post","summary":"tween.js - http://github.com/sole/tween.js JavaScript tweening engine for easy animations, incorporating optimised Robert Penner\u0026rsquo;s equations. JavaScript补间引擎，可轻松制作动画，并采用优化的Robert Penner方程。 1.基本用法(Usage","tags":["tween.js","tween","动画"],"title":"Tween.js","type":"post"},{"authors":null,"categories":null,"content":"Linux基本操作 ls -ah 查看所有文件,包括隐藏文件 pwd print working directory 打印当前路径 mv oldname.js newname.js 重命名 cat 查看当前文件 cp: cp \u0026lt;file\u0026gt; \u0026lt;path\u0026gt; 复制file到path路径 cp \u0026lt;file\u0026gt; \u0026lt;copy_name\u0026gt; 复制file并命名为copy_name,到当前路径 touch \u0026lt;file\u0026gt; 创建一个文件 rm -f \u0026lt;file\u0026gt; 删除一个文件 rm -rf \u0026lt;file package\u0026gt; 删除一个文件夹 uname print system information tty 显示当前终端 tar tar -x 解压 tar -v 显示解压过程 tar -f 要操作的文件名 ----------------------------------------------------------------- git基本操作 git是分布式版本控制系统 git 基本操作 git init 初始化仓库 git add \u0026lt;file\u0026gt; 添加file到仓库暂存区 git commit 将暂存区的内容提交到master git status 获取当前的git状态,查看哪些文件操作过 git diff \u0026lt;file\u0026gt; 查看file更改的详细信息 git log 查看当前git的信息 git reset --hard HEAD^ 回退到HEAD之前的一个版本 git reflog 查看提交的不同版本commit号和具体信息 git checkout --\u0026lt;file\u0026gt; 还没有进行git add \u0026lt;file\u0026gt;的操作,回退该文件最近提交的一个版本 git reset HEAD \u0026lt;file\u0026gt; 进行了git add \u0026lt;file\u0026gt;的操作,先进行该步操作,然后再使用git checkout --\u0026lt;file\u0026gt; git rm 删除一个仓库的文件并且提交git commit ssh-keygen -t rsa -C \u0026quot;youremail@example.com\u0026quot; 查看本地的ssh git remote add origin \u0026lt;github上创建的目录的ssh\u0026gt; 远程连接库和本地库 git push -u origin master 将本地的文件全部上传到远程仓库中 之后可以直接用git push 上传文件 在git push的时候寝室断电了怎么办? 断电导致reference broken，commit操作和push操作都会出现问题。最好的办法就是把.git文件删除重新git init一下之后再进行操作 .gitmodules =\u0026gt; git submodules update --init 查看GitHub上的html文件 加上前缀http://htmlpreview.github.io/? ------------------------------------------------------------------ nginx nginx.conf 配置文件 nginx -s reload 重启nginx 123  \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-windows快捷键\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; alt + 鼠标双击图片 显示图片属性 alt + D 浏览器中聚焦到输入框\n","date":1542433787,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1542433787,"objectID":"fe3697195af2e586ab94755a19f8fb97","permalink":"https://kangzhiqing.com/post/command/","publishdate":"2018-11-17T13:49:47+08:00","relpermalink":"/post/command/","section":"post","summary":"Linux基本操作 ls -ah 查看所有文件,包括隐藏文件 pwd print working directory 打印当前路径 mv oldname.js newname.js 重命名 cat 查看当前文件 cp: cp \u0026lt;file\u0026gt; \u0026lt;path\u0026gt; 复制file到path路径 cp \u0026lt;file\u0026gt; \u0026lt;copy_name\u0026gt; 复制f","tags":["command","git","linux"],"title":"Command","type":"post"},{"authors":null,"categories":null,"content":" 1.scene 场景 scene就是一个可以放置物体、灯光的3D空间，和现实中的一个空间相似，可大可小\n//创建一个场景 var scene = new THREE.Scene();  2.camera 相机 camera决定看一个物体的方式和位置，和现实中的相机行为相似，有很多种类的相机。\n PerspectiveCamera 透视相机  // 透视相机更加接近于现实中我们看物体的视角，远小近大 // 创建一个透视相机 var camera = new THREE.PerspectiveCamera(fov可视角度,aspect纵横比,near近端距离,far远端距离) // 设置camera的位置 camera.set(x,y,z)  3.渲染器  WebGLRenderer  var renderer = new THREE.WebGLRenderer()  4.几何形状  立方体(CubeGeometry)  CubeGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) // width,height,depth是分别在x,y,z方向上的长度,后面三个参数是对应的分段数,如果不需要分段可以不设置。几何中心在原点   平面(PlaneGeometry)  长方形平面,并非是无限延伸的平面\nPlaneGeometry(width, height, widthSegments, heightSegments) // width,height分别是x,y方向上的长度,后面两个参数是对应的分段数   球体(SphereGeometry)  SphereGeometry(radius, segmentsWidth, segmentHeight, phiStart, phiLength, thetaStart, thetaLength) // radius:半径,segmentWidth:纬度上切片数,segmentHeight:经度上的切片数,phiStart:经度开始的弧度,phiLength:经度跨过的弧度,thetaStart:纬度开始的弧度,thetaLength:纬度跨过的弧度   文字形状   使用额外的文字形状需要下载和引用额外的字体库,下载对应的json文件放在目录下,用下面的方法引用 传送门:https://github.com/mrdoob/three.js/tree/master/examples/fonts\nvar loader = new THREE.FontLoader(); loader.load('../gentilis_regular.typeface.json', function(font) { var text = new THREE.Mesh( new THREE.TextGeometry('KZQ',{ font:font, size:1, height:1 }), new THREE.MeshNormalMaterial(); scene.add(text); renderer.render(scene, camera); ) })  4.物体  Mesh 构造器  // 基于以三角形为polygon mesh多边形网格的物体的类 Mesh(geometry:Geometry,material:Material)   Object3D()  Object3D是大部分物体的基类，大部分的物体都可以通过Object3D构建\nvar object = new Object3D();  5，加载器  ImageLoader  // 初始化一个加载器 var loader = new THREE.ImageLoader(); // 加载一个图片资源 loader.load( // 资源URL './image/1.jpg', // onLoad回调 function(image){ var canvas = document.createElement('canvas'); var context = canvas.getContext('2d'); context.drawImage(image,100,100) } )  6.控制器  OrbitControls   // 构造器(Constructor) var controls = new THREE.OrbitControls(object:camera,domElement:HTMLDOMElement); // 属性(Properties) 1 .maxDistance 滚轮能放大的最大距离 2 .minDistance 滚轮能缩小的最小距离 // 方法(methods) 1 .update() 更新控件,一般用在手动更新camera变换后调用,或者在更新循环中调用 var controls = new THREE.OrbitControls(camera,renderer.domElement); camera.position.set(0,0,5000); controls.update() function animate(){ requestAnimationFrame(animate); controls.update() }   TrackballControls  球形控制器，以物体为中心，鼠标左键控制旋转，右键平移\n// 构造器(Constructor) var controls = new THREE.TrackballControls(camera, renderer.domElement)  8.其他  Vector3 3D矢量  var vector = new THREE.Vector3(x,y,z); // 如果没有参数，则是指向一个(0,0,0)的矢量;  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;使用three.js创建一个球\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;three.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;OrbitControls.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; // 创建一个场景 var scene = new THREE.Scene(); // 创建一个透视视图相机 var camera = new THREE.PerspectiveCamera(45,window.innerWidth/innerHeight,1,1000); // 设置相机的位置(x,y,z) camera.position.set(0,0,5); // 创建一个渲染器 var renderer = new THREE.WebGLRenderer(); // 设置渲染器的大小 renderer.setSize(window.innerWidth,window.innerHeight); // 设置背景颜色 renderer.setClearColor(0xfff6e6) // 插入到页面当中 document.body.appendChild(renderer.domElement); // 开始渲染(表演开始....) // 创建一个球使用SphereGeometry() var geomery = new THREE.SphereGeometry(1,22,22); // 选择材料 var material = new THREE.MeshNormalMaterial({wireframe:true}); // 创建网格对象 var sphere = new THREE.Mesh(geomery, material); // 加入到场景(舞台)当中 scene.add(sphere); // 创建一个控制器 var controls = new THREE.OrbitControls(camera,renderer.domElement); controls.addEventListener('change',function(){ renderer.render(scene,camera) }) // 渲染 renderer.render(scene,camera) // var animation = function(){ // requestAnimationFrame(animation); // sphere.rotation.x += 0.01; // sphere.rotation.y += 0.01; // renderer.render(scene,camera) // } // animation() \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  ","date":1542383032,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1542383032,"objectID":"e45467cc2b9bc31e09fb9ac07d0a11e9","permalink":"https://kangzhiqing.com/post/threejs/","publishdate":"2018-11-16T23:43:52+08:00","relpermalink":"/post/threejs/","section":"post","summary":"1.scene 场景 scene就是一个可以放置物体、灯光的3D空间，和现实中的一个空间相似，可大可小 //创建一个场景 var scene = new THREE.Scene(); 2.camera 相机 camera决定看一个","tags":["THREE","three","three.js","3D"],"title":"Three.js","type":"post"},{"authors":null,"categories":null,"content":" 1. return !1 和 return false 以及 return 0! 和 return true写法有什么区别 tween.min.js的源码 update: function(c) { if (0 === a.length) return !1; for ( var b = 0, d = a.length, c = void 0 !== c ? c : Date.now(); b \u0026lt; d; ) a[b].update(c) ? b++ : (a.splice(b, 1), d--); return !0; }  2. void 和 undefined 有什么区别(详细请看这里) A : void是一种操作符,无论void后的表达式是什么，void操作符都会返回undefined.但undefined不是保留字,undefined可以作为变量使用,所以在使用undefined作为变量名的时候容易出错,因此使用void可以确保取到undefined值\nfunction x() { var undefined = 'hello world', f = {}, window = { 'undefined': 'joke' }; console.log(undefined);// hello world console.log(window.undefined); //joke console.log(f.a === undefined); //false console.log(f.a === void 0); //true }   void还有一个经常使用到的作用,就是在a标签的href中使用,填充href,使它不跳转而是进行一些交互,比如在许多网站中的收藏,快转功能.  \u0026lt;a href=\u0026quot;javascript:void(0)\u0026quot;\u0026gt;   生成一个空的src的img标签的最好的方式似乎是使用src=\u0026quot;javascript:void(0)\u0026quot; 详情请看What\u0026rsquo;s the valid way to include an image with no src?  \nTip : 关于此问题更加详细请看这里\n3.null!=a 和 a!=null的区别 4.常见的获取元素宽高的方式及其区别  dom.style.width/height 这种方式只能获取dom元素内联样式的宽高，而style标签的样式和外联样式使获取不到的。修改样式用这个还是可以的 dom.currentStyle.width/height 无论哪种样式都可以获得，不过只有IE浏览器支持(我亲测了chrome和firefox都是不兼容的)。只读 window.getComputedStyle(element,[preudoElt]).width/height 首先getComputedStyle(element,[preudoElt])返回的是一个实时的css属性对象preudoElt是伪元素(可选),对于普通元素就是设置为null即可。兼容性更好(IE、firefox、chrome都可以)。只读 dom.offsetWidth/offsetHeight 兼容性很好，常用，且返回值是数字，不带单位。只读 dom.getBoundingClientRect().width/height getBoundingClientRect()返回的是一个元素的绝对位置的DomRect对象，里面有top、bottom、left、right、width、height,IE不兼容getBoundingClientRect(),IE兼容getClientRects(),其他浏览器都兼容，返回值是数值，不带单位。只读  \n以上，个人觉得offsetWidth比较方便一些\n5.window.onload和$(document).ready()方法的区别 A：window.onload事件会在页面所有元素加载完成后立即发生。而$(document).ready()是在DOM树加载完毕之后对其进行操作\n6.v-if和v-else使用应该注意什么？  他们必须是兄弟节点！！！ v-else上一个节点必须是v-if！！！   7. 常见的水平居中的方法？  text-align:center; (具有文本特性的元素水平居中,display为inline或者为inline-block) margin:0 auto (块级元素，且自身要有宽度) position:left;left:50%;margin-left:-元素高度/2; (元素高度已知) position:left;left:50%;transform:translateX(-50%); (元素高度未知) display:flex;justify-content:center;\n  8. 常见的垂直居中的方法？ 9. 常见的水平垂直居中的方法？ 10. calc使用注意事项 运算符前后必须要有空格，如calc(100% - 20px);\n11. background-size中cover和contain有什么区别 两者都是等比例缩放。 cover：如果容器的宽高比和照片的宽高比不同，那么图片就会等比例缩放到塞满整个容器，图片多余的部分就会被裁剪 contain：图片等比列缩放至全部都展示出来，所以可能会有留白\n12. js中关系运算符中大于和小于是怎么比较的？  字符串和字符串比较，比较第一个不同的字符的ASCII码 数字和纯数字字符串比较，将纯数字字符串转换为数字比较 数字和非纯数字字符串比较，返回false 特殊字符 null 和 undefined 进行比较的时候，null == undefined，undefined和除了null的其他所有值进行比较都是false  // 关系运算符 和 相等运算符 并不是一个类别的. // 关系运算符,在设计上,总是需要运算元尝试转为一个number . 而相等运算符在设计上,则没有这方面的考虑. // 最重要的一点, 不要把 拿 a \u0026gt; b , a == b 的结果 想当然的去和 a \u0026gt;= b 建立联系. 正确的符合最初设计思想的关系是 a \u0026gt; b 与 a \u0026gt;= b是一组 . a == b 和其他相等运算符才是一组. 比如 a === b , a != b, a !== b . null \u0026gt; 0 // null尝试转型为number，则为0，所以结果是false null \u0026gt;=0 // null尝试转型为number，则为0，所以结果是true null == 0 // null在设计上不尝试转型，所以结果是false  关于null的问题，参考了关于这个问题的回答=\u0026gt;传送门\n13.JS引擎中对变量的查询方式LHS和RHS有什么区别？ LHS和RHS是JS引擎的两种查找方式，赋值操作的左侧和右侧 LHS：找到目标，对其赋值，赋值操作的目标 RHS：找到源头，得到ta的原值，赋值操作的源头 不同的查找方式结果不一样，如果查找到最顶层的全局作用域下也没有找到变量的话，RHS查找就会抛出异常，而LHS查找方式在非严格模式会在全局作用域隐式的创建该变量，而严格模式则一样会抛出ReferenceError（ES5推出的严格模式不允许自动或者隐式的创建变量） 简单的说就是，如果查找的目的是对变量进行赋值，那么就会使用LHS查询，如果目的是获取变量的值，就会使用RHS查询。\n14.什么是闭包？ 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。函数的执行期上下文没有被销毁\n15.Object.create(null)和{}创建空对象的方式有什么区别？ Object.create(null)创建的对象比{}更‘空’，因为前者是没有创建Object.prototype原型的，而{}则会创建这个原型。\n16.如何判断this指向？ 1.由new调用？绑定到新创建的对象 2.由call或者apply或者bind调用？绑定到指定的对象 3.由上下文对象调用？绑定到那个上下文对象 4.默认：在严格模式下绑定到undefined，非严格模式绑定到全局对象\n17.什么是事件冒泡和捕获？一个事件的执行顺序是怎样的？ 事件冒泡和捕获都是事件的执行顺序，事件捕获是从上到下依次执行，而事件冒泡是从下到上执行。DOM事件流分三个阶段：捕获阶段=\u0026gt; 目标阶段（真正的目标节点正在处理事件的阶段） =\u0026gt; 冒泡阶段，就好比猛地将一个瓶子扔到水里，它会下沉一段距离，然后再浮上来。\n18.什么是事件委托？有什么用？ 事件委托是利用事件冒泡的原理，避免过多的操作DOM元素，利用其父级元素完成相应的事件操作。优化页面。\n19.addEventListener 和 onclick一类 绑定事件有什么区别？  addEventListener可以给一个事件绑定不同的监听器，而onclick一类只能一个事件只能绑定一个，同时绑定多个会覆盖。 addEventListener更加灵活，可以选择事件执行顺序是冒泡（第三个参数为false）还是捕获（第三个参数为true）  20. proto 和 prototype有什么区别？ 21. instanceof的用法？ 22. 常见js迭代器？  forEach some every for\u0026hellip;in 遍历索引 for\u0026hellip;of 遍历元素  23.LF 和 CRLF 换行符有什么不同? 一些题目 1 关于this指向\n// this指向的是调用它的对象，如果没有直接调用对象，会指向undefined或者window，一般都会指向window，在严格模式下才会指向undefined function a(xx){ this.x = xx; return this; }; var x = a(5); // window.x = 5 , return this, x = window var y = a(6); // window.x = 6 , return this, y = window console.log(x.x); // x = 6 , x.x =\u0026gt; undefined console.log(y.x); // y = window , widow.x = 6 // -----------------分割线----------------------- var name = '222'; var a = { name:'111', say:function(){ console.log(this.name); //谁调用this就指向谁 } } var fun = a.say; fun(); // this指向window, this.name = '222' a.say(); // this指向a, this.name = '111' var b = { name:'333', say:function(fun){ fun(); } } b.say(a.say); // say:function(fun){ // this;这里的this指向b // fun(); fun里面的this是在预编译过程中指向window的 //} // 所以这里的this.name = '222' fun() // this指向window, this.name = '222' b.say = a.say; b.say(); // this.name = '333' // -------------------分割线-------------------- function Point(x, y){ this.x = x; this.y = y; this.moveTo = function(x, y){ this.x = x; this.y = y; console.log(this.x + \u0026quot;,\u0026quot; + this.y); } } var p1 = new Point(0,0); var p2 = {x:0,y:0}; p1.moveTo(1,1); // 1,1 p1.moveTo.apply(p2,[10,10]); // 10,10 // -------------------分割线--------------- var num = 10; var obj = { num:0, inner:{ num:6, print:function(){ console.log(this.num); } } } num = 88; // 全局num变为88 obj.inner.print() // 6 var fn = obj.inner.print; fn(); // 88 (obj.inner.print)(); // 6 (obj.inner.print = obj.inner.print)(); // 0  ","date":1542333679,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1542333679,"objectID":"927258eba94b3d941902e01f348a90fc","permalink":"https://kangzhiqing.com/post/questions/","publishdate":"2018-11-16T10:01:19+08:00","relpermalink":"/post/questions/","section":"post","summary":"1. return !1 和 return false 以及 return 0! 和 return true写法有什么区别 tween.min.js的源码 update: function(c) { if (0 === a.length) return !1; for ( var b = 0, d = a.length, c = void 0 !== c ? c : Date.now(); b \u0026lt; d; )","tags":["Question"],"title":"Q \u0026\u0026 A","type":"post"},{"authors":null,"categories":null,"content":" perspective 设置元素被查看位置的视图\ndiv{ perspective:500px; }  column main{ column-count:4; /*固定列数*/ column-width:12em; /*列宽*/ column-gap:2em; /*每列的间距*/ column-rule:thin dotted #999; /*列之间样式*/ }  word-wrap 吗， - normal 默认\n break-word 长的url或者链接内部换行  水平滚动（比如图片很多） ","date":1541078542,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1541078542,"objectID":"a8face6dc9bf3e1e75afb9c8348bcede","permalink":"https://kangzhiqing.com/post/css3property/","publishdate":"2018-11-01T21:22:22+08:00","relpermalink":"/post/css3property/","section":"post","summary":"perspective 设置元素被查看位置的视图 div{ perspective:500px; } column main{ column-count:4; /*固定列数*/ column-width:12em; /*列宽*/ column-gap:2em; /*每列的间距*/ column-rule:thin dotted #999; /*列之间样式*/ } word-wrap 吗， - normal 默认 break-word 长的url","tags":["CSS","property"],"title":"Css3Property","type":"post"},{"authors":null,"categories":null,"content":" typeof返回一个字符串,表示为经计算的操作数的类型 typeof(操作数)/typeof 操作数 ()是可以省略的 返回有五种基本类型:string,number,boolean,undefined,function,object 还有ES6的Symbol\n// 1.string: typeof('你好') typeof('123') typeof('') // 空字符串也是String类型 typeof(typeof('a')) // 2.number: typeof(123); typeof(NaN); // 3.boolean: typeof(true); typeof(false); typeof(NaN===NaN) // 强制类型转换 // 4.undefined: typeof(a) // 未经使用的变量的数据类型 // 5.object: typeof(null) // js底层所有值的前三位表示数据类型,object是000,而null的32位全是0,因此也是object typeof([]) typeof({}) // 6.function: typeof(function(){}) typeof(new Function()) typeof(class A{}) typeof(Symbol) // 7.symbol: typeof(Symbol())  暂时性死区 在ES6中let和const出现之前,typeof都是一个完全安全的操作,即不会报错,但有了ES6中let和const的出现所带来的暂时性死区特性,使得typeof也有可能报错\n如果在一个块级作用域下存在let或const命令,则它所声明的变量就绑定在这个区域,不再受外部的影响.在声明之前使用这些变量就会报错.使用let命令声明变量之前是不可用的,这在语法上称为暂时性死区\ntypeof(a); //ReferenceError let a;  ","date":1541065939,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1541065939,"objectID":"1d830bace5d0c7993468566a34f4c9a0","permalink":"https://kangzhiqing.com/post/typeof/","publishdate":"2018-11-01T17:52:19+08:00","relpermalink":"/post/typeof/","section":"post","summary":"typeof返回一个字符串,表示为经计算的操作数的类型 typeof(操作数)/typeof 操作数 ()是可以省略的 返回有五种基本类型:stri","tags":["JS"],"title":"Typeof","type":"post"},{"authors":null,"categories":null,"content":" Canvas 是 HTML5 新增加的一个元素,它又称为\u0026rdquo;画布\u0026rdquo;,主要有以下四种功能\n 绘制图形 绘制图表 动画效果 游戏开发  在 chrome 浏览器中,canvas 的默认宽高是 300px 和 150px,写宽高的样式的时候最好写在 HTML 页面的属性值里面\n\u0026lt;canvas width=\u0026quot;150\u0026quot; height=\u0026quot;100\u0026quot; style=\u0026quot;border: 1px black dashed\u0026quot;\u0026gt;\u0026lt;/canvas\u0026gt;  一般的操作 1.获取 canvas 对象 2.获取上下文环境对象 context\ncxt = canvas.getContext(\u0026quot;2d\u0026quot;);  3.开始绘制图形\n1.直线 cxt.moveTo(x1,y1) 画笔移到(x1,y1)处 cxt.LineTo(x2,y2) 画笔从起点(x1,y1)开始画线,一直到终点(x2,y2)处 cxt.strokeStyle = \u0026quot;red\u0026quot; 设置线的颜色 cxt.stroke() 用笔划线 (tip:cxt.strokeStyle要在cxt.stroke()之前执行,否则是看不到效果的,和画画是一样的,在动笔之前把要画的东西,颜色,样式确定好  2.描边矩形 填充矩形 清空矩形  描边矩形  cxt.strokeRect(x1,y1,x2,y2) (x1,y1)为矩形左上角坐标,(x2,y2)为矩形右下角坐标 等价于==\u0026gt; cxt.rect(x1,y1,x2,y2); cxt.stroke();   填充矩形  cxt.fillStyle = \u0026quot;属性值\u0026quot; cxt.fillRect(x1,y1,width,height) (x1,y1)是矩形左上角坐标,width是矩形的宽度,height是矩形的高度 等价于==\u0026gt; cxt.rect(x1,y1,x2,y2); cxt.fill()   清空矩形  cxt.clearRect(x1, y1, x2, y2);   绘制一个正 n 多边形  \u0026lt;canvas width=\u0026quot;100\u0026quot; height=\u0026quot;50\u0026quot; style=\u0026quot;border: 1px black dashed\u0026quot;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;script\u0026gt; var canvas = document.getElementsByTagName('canvas')[0] var cxt = canvas.getContext('2d'); //获取上下文环境对象 var cvs_width = parseFloat(getComputedStyle(canvas, null).width); //获取画布的宽 var cvs_height = parseFloat(getComputedStyle(canvas, null).height); //获取画布的高 var distanceR = distanceD = 0 function createPolygon(n) { var r = Math.min(cvs_width, cvs_height)/2; //正多边形外接圆半径 if(Math.min(cvs_width,cvs_height)==cvs_height){ distanceR = (cvs_width/2) - r }else{ distanceD = (cvs_height/2) - r } var degree = (2 * Math.PI) / n; //每个角的度数 cxt.moveTo(0+distanceR, r+distanceD); //初始化起点 for (let i = 1; i \u0026lt; n; i++) { cxt.lineTo(r - r * Math.cos(i * degree)+distanceR, r + r * Math.sin(i * degree)+distanceD); } cxt.closePath(); cxt.fillStyle = \u0026quot;#f40\u0026quot;; cxt.fill() } \u0026lt;/script\u0026gt;  2.曲线  圆形  cxt.beginPath() 开始一个路径 cxt.arc(x,y,半径,开始角度,结束角度,anticlockwise) // (x,y)时圆心的坐标,开始角度和结束角度都是弧度制,anticlockwise(逆时针地)为true时,逆时针绘制图形,为false时,顺时针绘制图形 cxt.closePath() 结束一个路径 // 描边 cxt.strokeStyle = \u0026quot;颜色值\u0026quot; cxt.stroke() 画线 // 或者填充 cxt.fillStyle() cxt.fill()   弧形  1.arc() // 和画圆基本语法一样,就是把cxt.closePath()去掉就好了 2.arcTo(cx,cy,x2,y2,radius) // 控制点坐标(cx,cy) 终点坐标(x2,y2) radius是圆弧半径 起点坐标(x1,y1)由一般由moveTo()或lineTo()提供   二次贝塞尔曲线  cxt.quadraticCurveTo(cx,cy,x2,y2) // (cx,cy)控制点坐标,(x2,y2)终点坐标,起点坐标由moveTo()或lineTo()提供   三次贝塞尔曲线  cxt.bezierCurveTo(cx1,cy1,cx2,cy2,x,y) //(cx1,cy1)控制点1的坐标,(cx2,cy2)控制点2的坐标,(x,y)表示结束点坐标,起点坐标由moveTo()或lineTo()提供  3.线条操作 lineWidth //线条宽度(px) lineCap //线帽样式 Butt默认值无键帽,Round圆形键帽,Square正方形键帽 lineJoin //线条交接处样式 miter默认值尖角,round圆角,bevel斜角  canvas应用实例 （1）星光闪闪 先上效果 \u0026lt;canvas id=\u0026quot;myCanvas\u0026quot;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;script\u0026gt; // 获取画布 var myCanvas = document.getElementById('myCanvas'); // 画笔 var ctx = myCanvas.getContext('2d'); // 创建一个列表存放位置信息 var list = []; // 初始化画布 function init(){ myCanvas.width = window.innerWidth; myCanvas.height = window.innerHeight; } init(); // 每当窗口大小变化的时候重新初始化 window.onresize = init; // 初始化位置 for(let i=0; i\u0026lt;777; i++){ // 圆点的位置 var x = Math.random() * myCanvas.width; var y = Math.random() * myCanvas.height; // 圆的半径 var r = Math.random() * 5; // 圆的偏移量,发散的移动，以中间为界限，左上的向左上角移动，右上的向右上角移动，左下向左下角移动，右下向右下角移动 var disX = x - myCanvas.width / 2; var disY = y - myCanvas.height / 2; list.push({ x:x, y:y, r:r, disX:disX, disY:disY }); } // 绘制函数 function render(){ // 每次都把画布更新 ctx.clearRect(0,0,myCanvas.width,myCanvas.height); for(var i=0;i\u0026lt;list.length;i++){ var item = list[i]; // 圆点移动 item.x += item.disX / 50; item.y += item.disY / 50 // 判断小圆点消失 if(item.x \u0026lt; 0 || item.y\u0026lt;0 ||item.x\u0026gt;myCanvas.width || item.y \u0026gt; myCanvas.height){ // 每次消失重新生成圆点 item.x = Math.random() * myCanvas.width; item.y = Math.random() * myCanvas.height; item.disX = item.x - myCanvas.width/2; item.disY = item.y - myCanvas.height/2; } // 开始绘制 ctx.beginPath(); // 填充颜色 ctx.fillStyle = \u0026quot;rgb(\u0026quot;+random(0,255)+','+random(0,255)+','+random(0,255)+')'; // 绘制圆 ctx.arc(item.x,item.y,item.r,0,Math.PI*2,false); ctx.fill(); } // 每40毫秒重新绘制 setTimeout(render,40); } render(); function random(left,right){ return Math.random() * (right-left+1) + left } \u0026lt;/script\u0026gt;  ","date":1540983137,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1540983137,"objectID":"d084150bb5d312defc4e3d00117942d2","permalink":"https://kangzhiqing.com/post/canvas/","publishdate":"2018-10-31T18:52:17+08:00","relpermalink":"/post/canvas/","section":"post","summary":"Canvas 是 HTML5 新增加的一个元素,它又称为\u0026rdquo;画布\u0026rdquo;,主要有以下四种功能 绘制图形 绘制图表 动画效果 游戏开发 在 chrome 浏览器中,canva","tags":["CSS","Canvas"],"title":"CSS3 Canvas","type":"post"},{"authors":null,"categories":null,"content":" sam ├─archetypes ├─exampleSite │ ├─content │ │ ├─gallery │ │ │ └─images │ │ │ └─small │ │ └─posts │ ├─resources │ └─static │ └─img ├─images ├─layouts │ ├─gallery │ ├─partials │ ├─posts │ └─_default ├─sass └─static └─css  ","date":1540909347,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1540909347,"objectID":"a6621a83656e41a509da0b68020cc6ed","permalink":"https://kangzhiqing.com/post/sam/","publishdate":"2018-10-30T22:22:27+08:00","relpermalink":"/post/sam/","section":"post","summary":"sam ├─archetypes ├─exampleSite │ ├─content │ │ ├─gallery │ │ │ └─images │ │ │ └─small │ │","tags":["blog","story"],"title":"Hugo主题sam","type":"post"},{"authors":null,"categories":null,"content":" mysql数据库是我今年暑假在家学习的，当时学习的时候写了一些笔记，现在把笔记整理到博客上。\nTips  sql语句的语法Windows下是不区分大小写的，但在Linux是严格区分的，最好还是用大写吧 单双引号表示字符没有区别 注释单行一般用 --，多行（块）用 /* */ 命名规范遵循基本的命名原则，具体因人而异，个人喜欢小驼峰  SQL语句分类  数据库查询语言DQL（datebase query language） SELECT 数据库定义语言DDL（datebase defined language）\nCREATE DATABASE、CREATE TABLE、DROP DATABASE、DROP TABLE 数据库操作语言DML（database manage language）\nUPDATE、INSERT、DELETE  数据类型属性 mysql常见的数据类型：varchar(n)、float、int(n)、bigint(n)、date、datetime、text\n 默认值 default '默认值' 非空：NOT NULL 如果某一个字段别NOT NULL修饰后，添加数据时，此字段必需填写 自动增长：auto_increment，尽量作用在int类型的字段上 主键(唯一的，不能重复，一张表中只能以一个作为主键)：primary key 唯一健（唯一，可以有很多）：unique，被unique修饰的数据不能够重复  一个栗子\nUSE kzq; DROP TABLE students; CREATE TABLE students( id BIGINT(20) AUTO_INCREMENT PRIMARY KEY COMMENT '学生编号', stuName VARCHAR(40) COMMENT '学生姓名', gender VARCHAR(2) DEFAULT '男' COMMENT '性别', className VARCHAR(20) NOT NULL COMMENT '班级', phone VARCHAR(20) UNIQUE COMMENT '手机号码' )  库与表的创建和删除 -- 创建库 CREATE DATABASE 库名 CHARACTER SET 编码名 CREATE DATABASE kzq CHARACTER SET utf8 -- 选中某一个数据库 USE 库名 USE kzq -- 创建表 CREATE TABLE 表名( 字段1 数据类型 COMMENT ....., -- COMMENT为注释（对该字段的具体信息的补充） -- 字段1和字段2之间注意不要漏写逗号',' 最后一个字段结尾没有符号 字段2 数据类型 COMMENT ....., ....... ) CREATE TABLE mysqlScore( stuName VARCHAR(40) COMMENT \u0026quot;学生姓名\u0026quot;, stuClass VARCHAR(20) COMMENT \u0026quot;学生班级\u0026quot;, stuScore FLOAT COMMENT \u0026quot;学生成绩\u0026quot; ); -- 删除库和表 -- 友情提示：删库需谨慎，正所谓MySQL从删库到跑路 DROP DATABASE 库名 DROP TABLE 表名 -- 查看所有库 SHOW DATABASE -- 查看创建库的详细信息 SHOW CREATE DATABASE 库名 -- 查看创建表的详细信息 SHOW CREATE TABLE 表名 -- 查看当前用户连接的是哪个数据库 SELECT DATABASE() -- 查看当前用户连接的库下的所有表 SHOW TABLES -- 查看某一张表的结构 -- DESC =\u0026gt; description DESC 表名  表的增（Create）、删（Delete）、改（Update）、查（Retrieve） 增 USE kzq -- 方法一 INSERT INTO 表名(字段1,字段2....) VALUES(值1,值2) INSERT INTO mysqlScore (stuName,stuClass,stuScore) VALUES ('刘仔','xxx',90.5) -- 在插入时，可以省略掉字段名，但后面的VALUES必须全 INSERT INTO mysqlScore VALUES ('刘仔','xxx',90.5) -- 同时插入多条数据 INSERT INTO mysqlScore (stuName,stuClass,stuScore) VALUES ('刘仔','xxx',90.5),('小刘','xxx',90.6) -- 方法二 INSERT INTO 表名 SET 字段名1=字段值1 INSERT INTO mysqlScore SET stuName='刘仔'  删 -- 如果\u0026quot;=\u0026quot;是放在SET关键字后，则是\u0026quot;赋值运算符\u0026quot; -- 如果\u0026quot;=\u0026quot;是放在WHERE关键字后，则是\u0026quot;关系运算符\u0026quot; DELETE FROM 表名 WHERE 条件 DELETE FROM mysqlScore WHERE stuName='刘仔' -- 如果要删除一整张表中的数据，使用truncate，使用truncate删除数据后，如果字段是自增的、则重新排列 TRUNCATE TABLE students;  改 -- 重命名表名 RENAME TABLE 旧表名 TO 新表名 RENAME TABLE aaa TO bbb; -- 添加字段 ALTER TABLE 表名 ADD 字段名 数据类型 ALTER TABLE person ADD gender VARCHAR(2) -- 删除字段 ALTER TABLE 表名 DROP 被删除字段名 ALTER TABLE person DROP gender -- 重命名字段 ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新字段名数据类型 ALTER TABLE person CHANGE aaa bbb VARCHAR(40) -- 修改数据类型（长度） ALTER TABLE person CHANGE aaa aaa VARCHAR(25)  查 ----- 基本查询 ------ -- 逻辑运算符 与and 或or 非not SELECT 字段1，字段2....FROM 表名 (WHERE 条件) SELECT stuName,stuClass,stuScore FROM mysqlScore; SELECT stuName FROM mysqlScore -- *代表所有字段 SELECT * FROM mysqlScore -- AS是取别名，WHERE后面是条件 SELECT stuName (AS passName) FROM mysqlScore WHERE stuScore\u0026gt;=60; -- 降序(DESC) SELECT * FROM mysqlScore ORDER BY stuScore DESC; -- 升序(ASC) SELECT * FROM mysqlScore ORDER BY stuScore ASC;  ----- 聚合函数查询 ----- SELECT 函数名（字段） FROM 表名 -- 找出最大值：max(字段) SELECT MAX(stuScore) AS maxScore FROM mysqlScore; -- 找出最小值：min(字段) SELECT MIN(stuScore) AS minScore FROM mysqlScore; -- 求平均数：avg(字段名) SELECT AVG(stuScore) AS avgScore FROM mysqlScore; -- 求和 sum SELECT SUM(stuScore) AS totalScore FROM mysqlScore; -- 统计记录 count SELECT COUNT(*) FROM mysqlScore -- 常用函数 SELECT NOW() -- 年月日、时分秒 SELECT CURTIME() -- 时分秒 SELECT CURDATE() -- 年月日 SELECT CEIL(2.3) -- 向上取舍 SELECT FLOOR(2.3) -- 向下取舍 SELECT RAND() -- 返回0到1的随机数 -- 时间格式函数 SELECT DATE_FORMAT(DATE,'%Y年%m月%d日 %H:%i:%s') AS birthday FROM persons  -------- 查询多条记录和分组查询 -------- -- 多条查询 SELECT * FROM users WHERE id IN (1,3) SELECT * FROM users WHERE id -- 查询是否有种类为衣服的类型 SELECT goodCategory FROM goods GROUP BY goodCategory HAVING goodCategory='衣服' -- 分页查询 -- limit 起始下标,每页显示的数据量 -- goods表中有七条数据记录，每一页显示三条，总共可以分3页 SELECT * FROM goods LIMIT 0,3; -- 第一页 SELECT * FROM goods LIMIT 3,3; -- 第二页 SELECT * FROM goods LIMIT 6,3; -- 第三页  --------- 多表查询 -------- select * from 表1,表2....表n where 条件 /* 多表查询方式： 内连接 外连接 左右连接 右外连接 */ -- 内连接 -- on后面接几个表中有关联的条件，没有关联的条件用where select * from 表1 inner join 表2 on 条件(多个表中有关联的条件) where 没关联的条件 -- 查新所有部门中的所有员工 SELECT * FROM dept d INNER JOIN emp e ON d.id = e.deptId -- 查询在开发部的员工姓名和收入 SELECT d.deptName,e.empName,e.salary FROM dept d INNER JOIN emp e ON d.id = e.deptId WHERE d.dept = '开发部' -- 左外连接 left join 以左边的表为主，左边的表数据要显示出来 -- 右外连接 right join 以右边的表为主，右边的表数据要显示出来  -------- 模糊查询 -------- LIKE 模糊查询 a% -- 以a开头，%为占位符 %a -- 以a结尾 %a% -- 包含a -- 查询中国拍摄的电影的id和title SELECT id,title FROM movies WHERE country LIKE '%中国%'  视图 在真实表上面构建的一张虚表 视图的应用场景：在金融行业，保险行业，财务行业等\nCREATE view 视图名 AS 查询语句; CREATE VIEW view_all AS SELECT e.empName,e.salary,d.deptname FROM dept d INNER JOIN emp e ON d.id = e.deptId; DROP VIEW view_all;  事务 -- 开启事务 START TRANSACTION; -- 回滚事务 ROLLBACK; -- 提交事务 COMMIT;  事务的四大特性  原子性(Atomicity)：多组操作为一个整体，不能分割，全部操作成功才算成功，有一步失败就失败了，一环扣一环。 一致性(Consistency)：操作前后最终的总量一样，比如说转账，两个人相互转账，这两个人无论向对方怎么转，两个人的总钱数是不变，如果变了，就说明失败了。 隔离性(Isolation)：并发(同一时刻多个事务执行)事务之间相互隔离互不干扰。\n 在mysql中事务有4种隔离级别：  read uncommitted(读取未提交) read committed(读取提交) repeatable read(可以重复读) Serializable  查看mysql软件的事务隔离级别 SELECT @@tx_isolation 修改mysql软件默认的隔离级别 set global transaction isolation level 隔离级别 不同的隔离级别会引发不同的问题  当mysql事务的隔离级别为read uncommitted时，会引发脏读(一个事务可以读取另一个事务未提交的数据.)，解决脏读问题可以将数据库事务的隔离级别改为:read committed 当mysql软件的事务隔离级别为:read committed的时候，会引发不可重复读：在同一事物中多次读取的结果不一致如何解决不可重复读：将事物的隔离级别改为repeatable read 当mysql软件的事务隔离级别为:repeatable read时，会引发虚读(幻读)    持久性(Durability)：数据进入到数据库中后，数据会持久存在\n  数据库的备份和还原  命令  备份 mysqldump -u root -p (密码) 需要备份的数据库名\u0026gt;备份后的sql文件名 mysqldump -u root -p (密码) kzq\u0026gt;c:\\kzqBack.sql 还原 进入mysql环境\u0026mdash;-\u0026gt;创建一个库\u0026mdash;-\u0026gt;在库下还原数据 source 备份数据库文件名  软件（图形界面操作sqlyog） 选中需要备份的数据库\u0026mdash;\u0026ndash;\u0026gt;右键\u0026mdash;\u0026mdash;\u0026gt;备份/导出\u0026mdash;-\u0026gt;转储到sql  未整理完的 MySQL存储过程以及一些示例\n","date":1540890390,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1540890390,"objectID":"2e66a82764fe3338b6bd32d0b3f47005","permalink":"https://kangzhiqing.com/post/mysql/","publishdate":"2018-10-30T17:06:30+08:00","relpermalink":"/post/mysql/","section":"post","summary":"mysql数据库是我今年暑假在家学习的，当时学习的时候写了一些笔记，现在把笔记整理到博客上。 Tips sql语句的语法Windows下是不区分大小写","tags":["数据库","关系型数据库","MySQL"],"title":"MySQL","type":"post"},{"authors":null,"categories":null,"content":" Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。我的博客网站就是通过Hugo来进行部署的,感谢Hugo,让我不需要重复造轮子. 官网:http://www.gohugo.org/ 1.下载 直接下载安装包 https://github.com/gohugoio/hugo/releases\n2.安装 windows10:解压安装包,会生成一个exe文件,在windows系统变量中添加当前路径到path.这样就算是安装成功了,之后都是在终端直接运行\n3.创建一个站点 hugo new site path/siteName 在path路径下生成一个叫siteName的站点  站点目录结构:\nsitname ├── archetypes │ └── default.md ├── config.toml 配置文件 ├── content 存放主要内容的目录 ├── data ├── layouts ├── static └── themes 主题目录  4.创建一篇文章 hugo new posts/blog.md 在content目录下生成posts/blog.md  5.下载主题和配置 url : https://themes.gohugo.io/\n(1)下载\n这些主题都托管在GitHub上,可以直接用git的下载方式下载 cd themes/ 进入themes目录 . git clone + 对应主题的地址 在readme.md中,作者会有对应git命令操作 . 直接在release最新发布版本中下载包  (2)配置 可以直接将下载的主题目录里面的 exampleSite/config.toml复制到站点根目录下覆盖初始化的config.toml文件 ( tip:注意config.toml文件中启用的主题名字是否和主题目录名一样,sam主题就是不一样的,不然就会加载主题失败 ) sam主题 ( https://themes.gohugo.io/hugo-theme-sam/ ) , 一个简约舒适的主题\n6.启动项目及部署 (1)启动本地服务 ▶ hugo server (--theme=\u0026lt;themeName\u0026gt;如果有多个主题可以进行选择) 一般在本地的1313端口运行 localhost:1313 or 127.0.0.1:1313 (2)部署到服务器中 ▶ hugo 会生成一个public的文件,如果要部署到服务器只要将该目录放到服务器之中 (类似于vue-cli的npm run build会生成一个dist目录的静态文件)  ","date":1540861893,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1540861893,"objectID":"894ecec029d0eb5908a28e83046e9787","permalink":"https://kangzhiqing.com/post/hugo/","publishdate":"2018-10-30T09:11:33+08:00","relpermalink":"/post/hugo/","section":"post","summary":"Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。我的博客网站就是通过Hugo来进行部署的,感谢Hugo,让我不","tags":["tool"],"title":"Hugo","type":"post"},{"authors":null,"categories":null,"content":" Hello World. This is my first blog. ","date":1540821580,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1540821580,"objectID":"3842110678af8aed7962464bf65102da","permalink":"https://kangzhiqing.com/post/helloworld/","publishdate":"2018-10-29T21:59:40+08:00","relpermalink":"/post/helloworld/","section":"post","summary":"Hello World. This is my first blog.","tags":["随记"],"title":"HelloWorld","type":"post"},{"authors":null,"categories":null,"content":"·\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"0fa87437f236ce950b95a720dbb481e7","permalink":"https://kangzhiqing.com/post/somestyle/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/post/somestyle/","section":"post","summary":"·","tags":null,"title":"","type":"post"}]