[{"authors":null,"categories":null,"content":"\n客官，欢迎来到我的博客网站，welcome~💃💃💃 一名在校大三学生，目前正在修的本专业是生物工程，双学位是计算机科学与技术，考研党一枚 主要分享一些我的学习经验和生活感想，也是对学习和生活的记录 有什么疑问或者其他的都可以联系我 ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":-62135596800,"objectID":"598b63dd58b43bce02403646f240cd3c","permalink":"https://kangzhiqing.com/author/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/admin/","section":"author","summary":"客官，欢迎来到我的博客网站，welcome~💃💃💃 一名在校大三学生，目前正在修的本专业是生物工程，双学位是计算机科学与技术，考研党一枚 主要分","tags":null,"title":"","type":"author"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":-62135596800,"objectID":"d41d8cd98f00b204e9800998ecf8427e","permalink":"https://kangzhiqing.com/author/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/","section":"author","summary":"","tags":null,"title":"Authors","type":"author"},{"authors":null,"categories":[],"content":" 目标  Name Content   目标专业 计算机科学与技术   专业方向 WEB 开发  目标院校 浙江大学   目标分数 380  --  \n购买书籍汇总  科目 书籍   数学   张宇高等数学18讲\n  李永乐线性代数辅助讲义\n  王式安概率论与数理统计辅助讲义   张宇考研数学1000题   408   王道复习全书\n\n 数学 2019年3月4日 =\u0026gt; 复习完线代行列式和矩阵基本知识\n英语 2019年3月4日 =\u0026gt; 考研单词已背1000个\n政治 408 数据结构 操作系统 计算机组成和原理 计算机网络 2019 年 2 月 了解考研基本的情况和复习的准备，需要购买什么资料、看什么视频，这些在知乎、b 站、贴吧都有对应的信息,并购买相应的资料\n2019 年 3 月 4 日 这个学期已经过去一个星期了，这个学期课还算是比较多的，加上双学位的课，确实有些忙碌。考研的路刚刚开始，但感觉自己的效率还是比较低，可能是太久没有这样准备考试了，总而言之，路是要慢慢的走的，踏踏实实的完成每日的复习任务。\n","date":1551670143,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1551670143,"objectID":"e800c23022d5e5e252d71103d1b8856e","permalink":"https://kangzhiqing.com/study/%E8%80%83%E7%A0%94/","publishdate":"2019-03-04T11:29:03+08:00","relpermalink":"/study/%E8%80%83%E7%A0%94/","section":"study","summary":"目标 Name Content 目标专业 计算机科学与技术 专业方向 WEB 开发 目标院校 浙江大学 目标分数 380 -- 购买书籍汇总 科目 书籍 数学 张宇高等数学18讲 李永乐线性代数辅助讲义 王","tags":[],"title":"考研","type":"study"},{"authors":null,"categories":[],"content":"  官网\u0026nbsp;\u0026nbsp;文档\nEntry Webpack的入口，通过入口文件，webpack开始搭建内部依赖网\n// webpack.config.js module.exports = { entry: './path/to/my/entry/file.js' };  Output 输出配置\nmodule.exports = { output: { filename: 'bundle.js', } };  Mode 主要是两种环境，开发环境（development）和生产环境（production），相应的环境，webpack会做出具体的优化方案。 （default：production）\nmodule.exports = { mode: 'production' // 'development' }  Loaders 加载器，用于加载资源，如scss文件或者将一些拓展语言（TypeScript,Scss）转换成合适的格式。 webpack内置可以处理的文件类型：JSON\nmodule.exports = { module: { rules: [ { test: /\\.css$/, use: 'css-loader' }, { test: /\\.ts$/, use: 'ts-loader' } ] } };   css-loader =\u0026gt; 处理.css文件 style-loader =\u0026gt; 通过\u0026lt;style\u0026gt;标签将css-loader内部样式注入到html中 Less-loader Sass-loader post-css-loader  Plugins 插件，webpack的支柱，webpack本身就是建立在类似的插件系统上的。 * banner-pulgin:\nWebpack-dev-server 安装依赖 npm install --save-dev webpack-dev-server  配置 module.export = { plugin:[ new webpack.HotModuleReplacementPlugin() // HMR功能插件 ] devServe:{ contentBase:'./public', // 本地服务器加载的页面所在目录 historyApiFallback:true, // true为不跳转，所有的跳转都会指向index.html inline:true // 为入口页面添加\u0026quot;热加载\u0026quot;功能 hot:true // 开启\u0026quot;热替换\u0026quot;（Hot Module Replacement HMR）功能 }, }  开启服务  直接在terminal中输入node_modules/.bin/webpack-dev-server,node_modeules下的.bin目录有许多执行文件可以直接运行\n 在package.json中的script对象中添加\u0026quot;server\u0026quot;:\u0026quot;webpack-dev-server\u0026quot;\n  \n在terminal中输入npm run server就可以了~\nBabel 编译Javascript的工具，使代码变得风骚，使用最新的javascript代码（ES6，ES7）并使用像react的JSX的扩展语言。 babel核心包 =\u0026gt; babel-core 解析ES6的包 =\u0026gt; babel-env-preset 解析JSX的包 =\u0026gt; babel-preset-react\nCSS模块化 利用css-loader和style-loader容易使全局样式遭到污染，css模块化通过将css的class名传递到具体的组件中，就可以有效的避免全局样式被污染\nmodules.export = { loader:{ rules:[ { test:/\\.css$/, use:[ { loader:\u0026quot;style-loader\u0026quot; }, { loader:\u0026quot;css-loader\u0026quot;, options:{ modules:true, localIdentName:'[name]__[local]--[hash:base64:5]' // css的类名格式 } ] } ] } }  ","date":1550212145,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1550212145,"objectID":"ff9f246211c7c78d9e90e0bab65fb5d8","permalink":"https://kangzhiqing.com/post/webpack/","publishdate":"2019-02-15T14:29:05+08:00","relpermalink":"/post/webpack/","section":"post","summary":"官网\u0026nbsp;\u0026nbsp;文档 Entry Webpack的入口，通过入口文件，webpack开始搭建内部依赖网 // webpack.config.js module.exports = { entry: './path/to/my/entry/file.js' }; Output 输出配置 module.exports = { output: { filename:","tags":["webpack"],"title":"Webpack","type":"post"},{"authors":null,"categories":[],"content":"官网\u0026nbsp;\u0026nbsp; 教程\u0026nbsp;\u0026nbsp; API\n\n  \n\n \n\n\n --  echarts.init(document.getElementById('bar')).setOption({ title:{ text:'柱状图' }, tooltip:{}, legend:{ data:['销量'] }, xAxis:{ data:[\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"] }, yAxis:{}, series: [{ type: 'bar', name: '销量', data: [5, 20, 36, 10, 10, 20] }] }); echarts.init(document.getElementById('pie')).setOption({ title:{ text:'饼状图' }, series: { name: '访问来源', type: 'pie', radius:'60%', data: [ {value:235, name:'视频广告'}, {value:274, name:'联盟广告'}, {value:310, name:'邮件营销'}, {value:335, name:'直接访问'}, {value:400, name:'搜索引擎'} ] } }); echarts.init(document.getElementById('line')).setOption({ title: {text: '直线图'}, tooltip: {}, toolbox: { // feature: { // dataView: {}, // saveAsImage: { // pixelRatio: 2 // }, // restore: {} // } }, xAxis: {}, yAxis: {}, series: [{ type: 'line', smooth: true, data: [[12, 5], [24, 20], [36, 36], [48, 10], [60, 10], [72, 20]] }] });  // 柱状图 echarts.init(document.getElementById('bar')).setOption({ title:{ text:'柱状图' }, tooltip:{}, legend:{ data:['销量'] }, xAxis:{ data:[\u0026quot;衬衫\u0026quot;,\u0026quot;羊毛衫\u0026quot;,\u0026quot;雪纺衫\u0026quot;,\u0026quot;裤子\u0026quot;,\u0026quot;高跟鞋\u0026quot;,\u0026quot;袜子\u0026quot;] }, yAxis:{}, series: [{ type: 'bar', name: '销量', data: [5, 20, 36, 10, 10, 20] }] }); // 饼状图 echarts.init(document.getElementById('pie')).setOption({ title:{ text:'饼状图' }, series: { name: '访问来源', type: 'pie', radius:'60%', data: [ {value:235, name:'视频广告'}, {value:274, name:'联盟广告'}, {value:310, name:'邮件营销'}, {value:335, name:'直接访问'}, {value:400, name:'搜索引擎'} ] } }); // 直线图 echarts.init(document.getElementById('line')).setOption({ title: {text: '直线图'}, tooltip: {}, toolbox: { // feature: { // dataView: {}, // saveAsImage: { // pixelRatio: 2 // }, // restore: {} // } }, xAxis: {}, yAxis: {}, series: [{ type: 'line', smooth: true, data: [[12, 5], [24, 20], [36, 36], [48, 10], [60, 10], [72, 20]] }] });  ","date":1550108556,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1550108556,"objectID":"911b65526fa40728aea9ae063180e2e7","permalink":"https://kangzhiqing.com/post/echarts/","publishdate":"2019-02-14T09:42:36+08:00","relpermalink":"/post/echarts/","section":"post","summary":"官网\u0026nbsp;\u0026nbsp; 教程\u0026nbsp;\u0026nbsp; API -- echarts.init(document.getElementById('bar')).setOption({ title:{ text:'柱状图' }, tooltip:{}, legend:{ data:['销量'] }, xAxis:{ data:[\"衬衫\",\"","tags":["Echarts","图表","数据"],"title":"ECharts","type":"post"},{"authors":null,"categories":null,"content":" Regular Expression\n正则表达式：匹配特殊字符或有特殊搭配原则的字符的最佳选择 创建方式  直接量 new RegExp();  // 直接量 var reg = /abc/ ; // new RegExp(); var reg = new RegExp(pattern. attribute); var reg = new RegExp(\u0026quot;abc\u0026quot;,\u0026quot;i\u0026quot;) var reg = new RegExp(/abc/i);  修饰符 /i ignoreCase 忽视大小写 /g global 全局匹配 /m multiline 多行匹配\n常用方法 str.match(reg) // 返回匹配成功的结果数组 str.search(reg) // 返回匹配到的位置，匹配不到返回-1 str.split(reg) str.replace(reg, newStr/function(){}) reg.test(str) // 匹配返回true，不匹配则返回false reg.exec() //  常用规则 \\w ==\u0026gt; [0-9A-z_] \\W ==\u0026gt; [^\\w] \\d ==\u0026gt; [0-9] \\D ==\u0026gt; [^\\d] \\s ==\u0026gt; [\\n\\f\\r\\t\\v] 空白字符 \\S ==\u0026gt; [^\\s] \\b ==\u0026gt; 单词边界 /\\bc/ 以c开头的单词 \\B ==\u0026gt; 非单词边界 . ==\u0026gt; [^\\r\\n] + ==\u0026gt; 匹配一次到无数次 {1, infinity} * ==\u0026gt; 匹配0次到无数次 {0, infinity} ? ==\u0026gt; 匹配0到1次 {0,1} ^ ==\u0026gt; 开头 $ ==\u0026gt; 结尾 | ==\u0026gt; 或 () ==\u0026gt; 子表达式 \\1 ==\u0026gt; 反向引用第一个子表达式一次 ()\\1 ==\u0026gt; 反向引用第一个子表达式一次 ()\\1\\1\\1 ==\u0026gt; 反向引用第一个子表达式两次  匹配原则：贪婪匹配原则（能匹配最多的） 如果要打破贪婪匹配就在量词后面加上？，则是非贪婪匹配\n正则表达式的属性 reg.global ==\u0026gt; 是否全局匹配 reg.ignoreCase ==\u0026gt; 是否忽略大小写 reg.multiline ==\u0026gt; 是否有换行匹配 reg.source ==\u0026gt; 返回正则表达式的文本 reg.lastIndex ==\u0026gt; 返回游标位置\n正向预查 正向断言 ?=/!= ==\u0026gt;断言表达式 var reg = /a(?=b)/g // 选择后面是b的a  Practice 1. 检验一个字符串首尾是否含有数字 var reg = /^\\d | \\d$/;  2. 将一个字符转换成小驼峰式写法 var str = \u0026quot;the-first-name\u0026quot;; var reg = /-(\\w)/g; str.replace(reg,function($,$1){ return $1.toUpperCase(); })  3. 字符串去重 var str = \u0026quot;aaaaaaaaaabbbbbbbbbbbbcccccccccc\u0026quot; var reg = /(\\w)\\1*/g; str.replace(reg,\u0026quot;$1\u0026quot;);  ","date":1548237113,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1548237113,"objectID":"bc8525c923206fc6b17fa768505b43bc","permalink":"https://kangzhiqing.com/post/regexp/","publishdate":"2019-01-23T17:51:53+08:00","relpermalink":"/post/regexp/","section":"post","summary":"Regular Expression 正则表达式：匹配特殊字符或有特殊搭配原则的字符的最佳选择 创建方式 直接量 new RegExp(); // 直接量 var reg = /abc/ ; // new RegExp(); var reg = new RegExp(pattern. attribute); var reg = new RegExp(\u0026quot;abc\u0026quot;,\u0026quot;i\u0026quot;) var reg = new RegExp(/abc/i); 修饰符","tags":["正则表达式"],"title":"RegExp","type":"post"},{"authors":null,"categories":null,"content":" 大致的一些计划\n非周日   Time Detail   7：00-7：30 起床、吃早饭   7：30-8：00 背英语单词  日常 刷一到两题LeetCode   其他时间 学习   17:00 运动（打羽毛球）   20：00 看有没有适合的课程学习，看看直播   22：30-23：00 读英文资料（不限）   23：00 洗漱、睡觉   周日   Time Detail   All FREE!!!   ","date":1547888161,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1547888161,"objectID":"60870bfb99bf58ef25c5695c680de004","permalink":"https://kangzhiqing.com/study/%E5%AF%92%E5%81%87%E8%AE%A1%E5%88%92/","publishdate":"2019-01-19T16:56:01+08:00","relpermalink":"/study/%E5%AF%92%E5%81%87%E8%AE%A1%E5%88%92/","section":"study","summary":"大致的一些计划 非周日 Time Detail 7：00-7：30 起床、吃早饭 7：30-8：00 背英语单词 日常 刷一到两题LeetCode 其他时间 学习 17:00 运动（打羽毛球","tags":null,"title":"寒假计划","type":"study"},{"authors":null,"categories":null,"content":" let 和 const ES6 新加了两种声明变量的方式，一个是 let，一个是 const。\n let 和 const 声明变量有自己的块级作用域（在 for 循环中用 let 声明的变量不会泄露到外部） let 和 const 声明变量在预编译的过程都不会进行变量提升 let 和 const 声明的变量不能再次声明，而 const 声明变量的时候必须同时赋值，并且不能再次赋值  { console.log(a); // ReferenceError:a is not undefined let a; } { let a = 1; let a = 2; // SyntaxError: Identifier 'a' has already been declared } { const a; // SyntaxError:Missing initializer in const declaration } { const a = 1; a = 2 // TypeError:Assignment to constant variable }  模板字面量  创建字符串不必再拼接了~  let a = { str: \u0026quot;模板字面量\u0026quot; }; console.log(\u0026quot;ES6\u0026quot; + a.str); // ES6 console.log(`ES6${a.str}`);   换行直接按下键盘的 Enter 就可以了  console.log(\u0026quot;ES6\\n模板字面量\u0026quot;); // ES6 console.log(`ES6 模板字面量`);  默认参数 function defalutPerson(person = \u0026quot;kzq\u0026quot;) { console.log(`The person is ${person}`); } defalutPerson(); defalutPerson(\u0026quot;HH\u0026quot;);  箭头函数  ES6 的箭头函数简化了函数的语法  var plus = function(a, b) { return a + b; }; // ES6箭头函数 var plus = (a, b) =\u0026gt; { return a + b; }; // 或者这样 var plus = (a, b) =\u0026gt; a + b;   箭头函数的 this 指向是固定的，即在箭头函数声明的时候就定义好了，继承来自外部最近的 this 指向  var x = 7; var obj = { x: 77, print: function() { console.log(this.x); } }; obj.print(); // obj调用的，则this指向obj，77 var obj = { x: 77, print: () =\u0026gt; { console.log(this.x); } }; obj.print(); // print是箭头函数，在声明的时候this就指向obj内部的this指向window，7 function test() { this.x = 7777; let print = function() { console.log(this); }; print(); } test(); // 全局调用this指向window，7 function test() { this.x = 7777; let print = () =\u0026gt; { console.log(this); }; print(); } test(); // 箭头函数print，print在定义的时候this就指向test，7777  解构赋值 var info = { name: \u0026quot;kzq\u0026quot;, age: 20, sex: \u0026quot;male\u0026quot; }; var { name, age } = info; console.log(name, age); var [, , lastNum] = [1, 2, 3];  扩展运算符(\u0026hellip;) // 合并数组 var person1 = [\u0026quot;kzq\u0026quot;, \u0026quot;lzj\u0026quot;, \u0026quot;hmy\u0026quot;, \u0026quot;dcb\u0026quot;]; var person2 = [\u0026quot;hh\u0026quot;, \u0026quot;hqy\u0026quot;, \u0026quot;xxbb\u0026quot;, \u0026quot;xx\u0026quot;]; var person = [...person1, ...person2]; // person2.push(...person) // 复制 var a = [1, 2, 3]; var oppA = [...a].reverse(); // 解构赋值 let { name1, name2, ...remainName } = { name1: \u0026quot;kzq\u0026quot;, name2: \u0026quot;hh\u0026quot;, name3: \u0026quot;wq\u0026quot;, name4: \u0026quot;xx\u0026quot; }; console.log(name1); // \u0026quot;kzq\u0026quot; console.log(name2); // \u0026quot;hh\u0026quot; console.log(remainName); // {name3:\u0026quot;wq\u0026quot;, name4:\u0026quot;xx\u0026quot;}  Object.assign 实现浅复制 var newObj = Object.assign(targetObj, sourceObj); // 把sourceObj复制给targetObj并返回targetObj  ","date":1546571018,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1546571018,"objectID":"5a6028d9a7312d5824c18b0eda244fb1","permalink":"https://kangzhiqing.com/post/es6/","publishdate":"2019-01-04T11:03:38+08:00","relpermalink":"/post/es6/","section":"post","summary":"let 和 const ES6 新加了两种声明变量的方式，一个是 let，一个是 const。 let 和 const 声明变量有自己的块级作用域（在 for 循环中用 let 声明的变量不会泄露到外部）","tags":["ES6"],"title":"ES6","type":"post"},{"authors":null,"categories":null,"content":"年末总结的开头就不感叹时光荏苒了（不过我还是要说一下时间过的是真的快呀！！！）  2018年的主要事迹如下= 报名计算机双学位 决定以后从事前端这个方向 学习  人呢，没有目标的时候是真的不知道自己在干嘛，我大二一年都是这样，平常正常上课，下课之后就基本没去碰生物方面的知识和技术，我认识到自己并不想从事生物方面的工作和研究，当初报考填写志愿也是比较匆忙，很随便。自己想想当初真的是很草率，高中的时候就没去了解相应的专业的信息，填写志愿的时候就瞎填。人呢，总是要做出选择，既然做出了选择就要面对相对应的事情。大二呢，也陆陆续续接触计算机语言python、爬虫方面的知识，发现自己对编程很感兴趣，给我的反馈也很多，也愿意花很多的时间去研究ta，所以到大二下看到信工学院的计算机科学与技术的双学位招新的消息，我就报了，打算以后从事互联网方面的工作。  暑假有两个月的时间，我没有选择去打暑假工，因为我太需要时间去学习，这两个月我基本都是在家里学习，7月份我学习了一种关系型数据库mysql还有scrapy爬虫，主要是想自己能够把一些信息爬下来并且存起来，但总感觉学习还是没有啥方向。到8月初，我室友叫我去学前端，暑假回来一起写写项目，我那时候正没有啥方向，刚好对前端也不是很了解，就去具体研究了一哈，我刚开始还以为JavaScript和Java有关系呢，我还问我室友要不要先学Java再学JavaScript，哈哈哈哈，现在想起来还是比较好笑的。那一个月就学习html，css，JavaScript，看网课还有一些文档，也决定以后就从事前端方向，月末模仿京东还有淘宝写了两个页面。  后面几个月就是陆陆续续进行前端的学习还有双学位的学习，虽然基本每个星期都比较忙，但感觉还是比较充实的。  关于学习上，这半年的学习，我发现原理是真的很重要，仅仅知道怎么用是远远不够，知其然也要知其所以然，还有就是不要为了解决问题而解决问题，很多东西容易忘，知道问题关键所在才能在后面遇到类似的问题也能解决。  关于游戏，还是和以前一样，英雄联盟和炉石传说，其他游戏基本没玩，很庆幸今年中国队终于夺冠了，大满贯耶，S8冠军，IG牛逼。今年没有去现场看比赛比较遗憾，现场的氛围是真的很high。联盟也打了5年了，真的久耶，从S4赛季到S8,今年打上钻石了，哈哈哈哈哈。炉石传说，别问，问就是蓝天白云，暴雪爸爸今年不怎么眷顾我，没怎么开出几张橙卡来。  最后，2018就要过去了，无论如何，感谢很多人，感谢自己，感谢2018。  再见，2018。你好，2019，加油~  ","date":1546244989,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1546244989,"objectID":"3e0fe0796ea3934617d9ca8a8868a976","permalink":"https://kangzhiqing.com/study/2018%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/","publishdate":"2018-12-31T16:29:49+08:00","relpermalink":"/study/2018%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/","section":"study","summary":"年末总结的开头就不感叹时光荏苒了（不过我还是要说一下时间过的是真的快呀！！！） 2018年的主要事迹如下= 报名计算机双学位 决定以后从事前端这个","tags":null,"title":"2018年末总结","type":"study"},{"authors":null,"categories":null,"content":" 感谢邱老师这一个学期的数据结构课的教导，让我了解到什么是数据结构和其重要性，以及相关的算法和实现。 这是一篇关于数据结构的复习。\n基本概念 1.程序 = 算法 + 数据结构 \u0026emsp; \u0026mdash;\u0026mdash; Nicklaus Wirth 一个程序就是通过具体的某种计算机语言将算法进行实现\n2.数据结构：相互之间存在一种或多种特定关系的数据元素的集合 具体什么是数据结构，包含下面三个部分=\u0026gt;\n 逻辑关系：线性关系、非线性关系 存储方式：顺序存储、链接存储、散列存储 （存储存的除了要存数据，还要存它们之间的关系，这一点是邱老师在刚上数据结构讲这些基本概念的时候特别强调的，我印象挺深的） 运算集合：查找和排序（插入=\u0026gt;直接法，二分法、交换=\u0026gt;冒泡排序，快速排序、选择=\u0026gt;堆排序）  3.算法：对特定问题求解步骤的一种描述。 一个算法还具有下列 5 个重要特性\n 有穷性\u0026emsp;一个算法必须在执行有穷步之后结束，但一个程序则可以无穷，比如说无限死循环 确定性\u0026emsp;算法的每一条指令必须有确切的含义 可行性\u0026emsp;一个算法是能行的 输入\u0026emsp;一个算法有零个或多个输入 输出\u0026emsp;一个算法有一个或多个输出  \n一个好的算法需要达到的目标\n 正确性 可读性 健壮性\u0026emsp;当输入数据非法时，算法也能做出反应或进行处理，即要可以处理一些特殊和极端情况 效率和低存储量需求\u0026emsp;时间复杂度低，算法执行时间短。满足需求的同时尽可能使用低的存储量消耗  4.时间复杂度：\u0026nbsp;算法中基本操作重复执行的次数是问题规模 n 的某个函数 f(n)，即 T(n) = O(f(n)) 5.空间复杂度：\u0026nbsp;算法所需存储空间的量度，即 S(n)=O(f(n))\n线性表 1.逻辑关系：线性关系/结构\n 存在唯一一个被称作\u0026rdquo;第一个\u0026rdquo;的数据元素 存在唯一一个被称作\u0026rdquo;最后一个\u0026rdquo;的数据元素 除第一个之外，集合中每个数据元素均只有一个前驱 除最后一个之外，集合中每个数据元素均只有一个后继  总的来说就是只有第一个元素有直接后继，没有前驱，只有最后一个元素有直接前驱，没有后继，在这两个元素之间的元素既有一个直接前驱也有一个直接后继\n\n2.存储方式和运算 （1）顺序存储：用一组地址连续的存储单元依此存储线性表中的数据元素\n// 在JavaScript中，数组就是一种隐式的存储关系 // 初始化数组 function listInit() { return new Array(); } // 插入=\u0026gt;第i-1个位置和第i个位置之间插入元素,i从1开始 function listInsert(list, i, data) { let len = list.length; if (i \u0026lt; 1 || i \u0026gt;= len + 1) { throw new Error(\u0026quot;i的位置有误\u0026quot;); } for (let j = len - 1; j \u0026gt;= i - 1; j--) { list[j + 1] = list[j]; } list[i - 1] = data; } // 删除=\u0026gt;删除第i个位置的元素 function listDelete(list, i) { let len = list.length; if (i \u0026lt; 1 || i \u0026gt; len) { throw new Error(\u0026quot;i的位置有误\u0026quot;); } for (let j = i - 1; j \u0026lt;= len - 1; j++) { list[j] = list[j + 1]; } // 切记不能用len--，因为是原始值，len改变并不会改变list.length list.length--; }  （2）链式存储：用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）\n 一个结点包含两个域，一个是数据域，一个是指针域，此链表的每个结点中只包含一个指针域，故又称为线性链表或单链表  // 单链表 function LinkListNode(data) { this.data = data; this.next = null; } var headNode = new LinkListNode(null); var len = 0; // 获取第i个元素 function getElem(i) { var p = headNode.next; var j = 1; while (p \u0026amp;\u0026amp; j \u0026lt; i) { p = p.next; j++; } return p ? p.data : null; } // 插入，在第i个位置之前插入元素e function linkListInsert(LinkListNode, i, e) { let newNode = new LinkListNode(e); var j = 1; p = headNode; if (i \u0026lt; 1 || i \u0026gt; len + 1) { return new Error(\u0026quot;i的范围有误\u0026quot;); } while (j \u0026lt;= i - 1 \u0026amp;\u0026amp; p.next) { p = p.next; j++; } newNode.next = p.next; p.next = newNode; len++; } // 删除，删除第i个位置的结点 function linkListDelete(i) { var j = 1; pre = headNode; p = pre.next; while (j \u0026lt; i \u0026amp;\u0026amp; p.next) { pre = p; p = pre.next; j++; } if (j == i) { return new Error(\u0026quot;超出链表范围\u0026quot;); } pre.next = p.next; len--; }   双向链表：结点有两个指针域，其一指向直接后继，另一指向直接前驱  // 双链表 function DuListNode(data, prior, next) { this.data = data || null; this.prior = prior || null; this.next = next || null; } var headNode = new DuListNode(); // 获取第i个位置的结点（i从1开始） function getDuList(i) { var p = headNode; var j = 1; while (j \u0026lt;= i \u0026amp;\u0026amp; p.next) { p = p.next; j++; } return p.data ? p.data : null; } // 获取表长 function getDuListLen() { var j = 0; var p = headNode; while (p.next) { p = p.next; j++; } return j; } // 在带头结点的双链表的第i个位置之前插入元素e function insertDuList(i, e) { if (i \u0026lt; 1 || i \u0026gt; getDuListLen() + 1) { return new Error( \u0026quot;i的范围应该不小于1且不大于表长加1,即len\u0026gt;=1 \u0026amp;\u0026amp; len\u0026lt;=\u0026quot; + (getDuListLen() + 1) ); } var j = 1; var p = headNode; var newNode = new DuListNode(e); while (p.next \u0026amp;\u0026amp; j \u0026lt; i) { p = p.next; j++; } if (p.next) { newNode.next = p.next; p.next.prior = newNode; p.next = newNode; newNode.prior = p; } else { p.next = newNode; newNode.prior = p; } } // 删除第i个位置的结点 function delDuListNode(i) { var j = 1; var p = headNode; if (getDuList(i) !== null) { while (j \u0026lt;= i) { p = p.next; j++; } } else { return new Error(\u0026quot;不存在第\u0026quot; + i + \u0026quot;个结点\u0026quot;); } p.prior.next = p.next; } // 打印每个结点(包含头结点) function printDuList() { p = headNode; while (p || (p \u0026amp;\u0026amp; !p.prior \u0026amp;\u0026amp; !p.next)) { console.log(p); p = p.next; } }   循环链表：表中最后一个结点的指针域指向头结点，整个链表形成一个环，从表中任一结点出发均可找到表中其他结点 其操作和单链表和双链表的操作差不多，只不过算法的循环条件变成了 p.next 是否为头指针或者 p 是否为头指针  栈和队列 栈 1.\u0026nbsp;逻辑结构：运算受限的线性表（限定仅在表尾进行插入或删除操作的线性表）\n FILO（First In Last Out）先进后出 LIFO（Last In First Out）后进先出 栈顶：表尾端 栈底：表头端  2.\u0026nbsp;存储和运算:\n 顺序栈  // 栈 function Stack() { // 数据 this.data = []; // 栈顶 this.top = 0; // 栈底 this.base = 0; // 入栈 this.entryStack = entryStack; // 出栈 this.exitStack = exitStack; // 返回栈顶元素 this.getTop = getTop; // 长度 this.length = getLength; } function entryStack(e) { this.data[this.top++] = e; } function exitStack() { return this.data[--this.top]; } function getTop() { return this.data[top - 1]; } function getLength() { return this.top - this.base; } // 利用栈进行数制转换 var s = new Stack(); var n = prompt(\u0026quot;请输入数字\u0026quot;); var d = prompt(\u0026quot;请输入要转换的进制\u0026quot;); console.log(n, d); while (n) { s.entryStack(n % d); n = parseInt(n / d); } while (s.length()) { console.log(s.exitStack()); } // 利用栈计算一个数的阶乘 var s = new Stack(); var n = prompt(\u0026quot;请输入你要计算的数：\u0026quot;); var result = 1; while (n \u0026gt; 1) { s.entryStack(n--); } while (s.length()) { result *= s.exitStack(); } console.log(result);   链栈  \n栈的链式表示 队列 1.逻辑结构\n FIFO（first in first out） LILO（last in last out） 一端进行插入，另一端删除元素 允许插入的一端叫做队尾（rear） 允许删除的一端叫做队头 （front）  2.存储和运算\n（1） 顺序存储\n// 队列 function Queue() { // 数据 this.data = []; // 队头 this.front = 0; // 队尾 this.rear = 0; // 获取队头 this.getFront = getFront; // 获取队尾元素 this.getRear = getRear; // 入队 this.entryQueue = entryQueue; // 出队 this.exitQueue = exitQueue; // 获取队列长度 this.length = getLength; // 队列是否为空 this.isQueueEmpty = isQueueEmpty; } function getFront() { return this.data[this.front]; } function getRear() { return this.data[this.rear - 1]; } function entryQueue(e) { this.data[this.rear++] = e; } function exitQueue() { return this.data[this.front++]; } function getLength() { return this.rear - this.front; } function isQueueEmpty() { return this.front == this.rear ? true : false; }  （2） 链式存储\n// 单链队列（不引入头结点） function linkQueue() { this.front = null; this.rear = null; this.length = 0; } linkQueue.prototype.qNode = function(e) { this.data = e; this.next = null; }; // 判断队是否为空 linkQueue.prototype.isQueueEmpty = function() { return this.front == this.rear \u0026amp;\u0026amp; this.front == null ? true : false; }; // 入队 linkQueue.prototype.entryQueue = function(e) { var newNode = new this.qNode(e); if (this.length == 0) { this.front = this.rear = newNode; } else { this.rear.next = newNode; this.rear = newNode; } this.length++; return true; }; // 出队 linkQueue.prototype.exitQueue = function() { if (!this.isQueueEmpty()) { var p = this.front; this.front = this.front.next; // 当队列最后一个元素出队后，队列的尾指针也丢失，则需要从新复制 if (this.rear == p) { this.rear = this.front; } this.length--; return p; } else { return new Error(\u0026quot;当前队列为空\u0026quot;); } }; // 打印当前队列 linkQueue.prototype.printQueue = function() { var str = \u0026quot;\u0026quot;; var p = this.front; while (p) { str += p.data + \u0026quot; \u0026quot;; p = p.next; } console.log(\u0026quot;当前队列为：\u0026quot; + str); };  （3）循环存储 设顺序存储队列用一维数组 q[m]表示，其中 m 为队列中元素个数，队列中元素在向量中的下标从 0 到 m-1。 在出队的时候，front 头指针向右移动，如果队尾指针指向 m-1，队列中仍有空闲单元，所以队列不是真的满了， 这时候入队操作，就会出现假溢现象。为了避免多余的空闲单元浪费（假溢出现），则引入循环队列，仅仅用 front==rear 无法判断队列空间是空还是满，有两种处理方法，一种是另外设置一个标志位来区别队空和队满的区别，另一种是少用一个元素空间，约定以“头指针在队尾指针的下一位置上”作为队列呈“满”状态的标志，这里是第二种\n// 循环队列 function CQueue(maxLength) { this.maxLength = maxLength; this.data = new Array(maxLength); // 初始化的时候头指针和尾指针都为0，每入队，rear指针加一，指向下一个位置 this.front = 0; this.rear = 0; this.length = 0; // 获取队列长度 this.getLength = function() { return (this.rear - this.front + this.maxLength) % this.maxLength; }; // 入队 this.entryQueue = function(e) { if ((this.rear + 1) % this.maxLength == this.front) { return new Error(\u0026quot;队列已满\u0026quot;); } this.data[this.rear] = e; this.rear = (this.rear + 1) % this.maxLength; this.length++; }; // 出队 this.exitQueue = function() { if (this.front == this.rear) { return new Error(\u0026quot;队列为空\u0026quot;); } var p = this.data[this.front]; this.front = (this.front + 1) % this.maxLength; return p; }; // 打印当前队列元素 this.printQueue = function() { var str = \u0026quot;\u0026quot;; var p = this.front; while (p % this.maxLength \u0026lt; this.rear) { str += this.data[p] + \u0026quot; \u0026quot;; p = (p + 1) % this.maxLength; } console.log(str); }; }  树和二叉树 1.逻辑结构：\n 树：n（n \u0026gt; 0）个节点的有限集 二叉数：每个结点的度最多为二（最多有两个子树）  2.存储和运算（二叉树）\n 顺序存储：用一组地址连续的存储单元依次自上而下，自左向右存储完全二叉数的结点元素，以‘0’表示不存在此结点。 链式存储  // 创建二叉树（这里实现二叉排序树） // 二叉排序树（Binary Sort Tree）BST：左子树上结点的值小于ta的根结点的值，而右子树上结点的值大于ta的根结点的值，没有键值相等的节点 function BinaryTree() { // 根节点 this.root = null; // 节点 this.Node = function(data) { this.data = data; // 左指针 this.left = null; // 右指针 this.right = null; }; // 插入 this.insert = function(data) { let newNode = new this.Node(data); if (this.root === null) { this.root = newNode; } else { this.insertNode(this.root, newNode); } }; this.insertNode = function(root, newNode) { if (newNode.data \u0026lt; root.data) { if (root.left === null) { root.left = newNode; } else { this.insertNode(root.left, newNode); } } else { if (root.right === null) { root.right = newNode; } else { this.insertNode(root.right, newNode); } } }; // 先序遍历 this.preOrderTraversal = function(callback) { this.preOrderTraversalNode(this.root, callback); }; this.preOrderTraversalNode = function(node, callback) { if (node !== null) { callback(node.data); this.preOrderTraversalNode(node.left, callback); this.preOrderTraversalNode(node.right, callback); } }; // 中序遍历（中序遍历二叉排序树得到的就是按从小到大的顺序访问所有节点） this.inOrderTraversal = function(callback) { this.inOrderTraversalNode(this.root, callback); }; this.inOrderTraversalNode = function(node, callback) { if (node !== null) { this.inOrderTraversalNode(node.left, callback); callback(node.data); this.inOrderTraversalNode(node.right, callback); } }; // 后序遍历 this.postOrderTraversal = function(callback) { this.postOrderTraversalNode(this.root, callback); }; this.postOrderTraversalNode = function(node, callback) { if (node !== null) { this.postOrderTraversalNode(node.left, callback); this.postOrderTraversalNode(node.right, callback); callback(node.data); } }; this.printNode = function(value) { console.log(value); }; // 获取BST中的最小值 this.minData = function(){ let p = this.root; while(p \u0026amp;\u0026amp; p.left){ p = p.left; } return p.data; } // 获取BST中的最大值 this.maxData = function(){ let p = this.root; while(p \u0026amp;\u0026amp; p.right){ p = p.right; } return p.data; } // 查询一个节点 this.findNode = function(key,node=this.root){ if(node !== null){ if(key \u0026lt; node.key){ this.findNode(key,node.left); }else if(key \u0026gt; node.key){ this.findNode(key, node.right); }else{ return node; } }else{ return null; } } // 移除一个节点 this.removeNode = function(key){ let p = root; while(p.data) if(node==null){ return null; } } }  3.二叉树的性质\n 在二叉数的第 i 层上至多有 2^(i-1)个结点（i\u0026gt;=1） 深度（树中结点 最大的层次）为 k 的二叉树至多有 2^k-1 个结点 2^0+2^1+\u0026hellip;+2^k-1 = 2^0(1-2^k)/1-2 = 2^k - 1 对任何一颗二叉数 T，如果度为 0 的结点树为 n0，度为 2 的结点数为 n2，则 n2 = n0 + 1 满二叉树：一颗深度为 k 且有 2^k-1 个结点的二叉数称为满二叉树 完全二叉树：深度为 k，有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应  ","date":1545787211,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1545787211,"objectID":"c7b115875cf971219a008c59f3845f7a","permalink":"https://kangzhiqing.com/post/datastructure/","publishdate":"2018-12-26T09:20:11+08:00","relpermalink":"/post/datastructure/","section":"post","summary":"感谢邱老师这一个学期的数据结构课的教导，让我了解到什么是数据结构和其重要性，以及相关的算法和实现。 这是一篇关于数据结构的复习。 基本概念 1.程","tags":["dataStructure","structure"],"title":"数据结构","type":"post"},{"authors":null,"categories":null,"content":"和林语堂先生在《苏东坡传》开篇写的那样，我写这篇读后感并没有什么特别的理由，只是以此为乐而已，且此篇读后感和以往写的不同，算是一篇读书笔记吧，边读边写，有所感悟便写下来。也是希望自己能在这个忙碌和大多数事情追求快的时代偶尔能够慢下来~ 故乡飘已远，往意浩无边。这句诗描绘的东坡二十左右一家进京任职的时候他的心境，故乡虽已远去，但去意浩瀚无边，此时的他满腹才华、自信以及对于仕途的向往和憧憬。在二十岁出头这个年纪，东坡可以说是文名日胜。 在描写苏夫人警惕东坡要提防那些过于坦白直率的泛泛之交，提放丈夫认为“天下无坏人”的大前提之下所照顾的那些朋友。林语堂先生觉得苏夫人的智慧是自“君子之交淡如水”得来的，水没有刺激的味道，但是人永远不会对之生厌。真诚的友谊永远不会特别表白的，真正的好朋友彼此不必通信，因为既是对彼此的友情信而不疑，谁也不需要写什么。一年分别后，再度相遇，友情如故。我觉得很多我和我高中的两个朋友之间就是如此，高中之后，大家各自分别，去了不同的学校上学，虽然在学校这些时间我们之间聊的天不多，但每每寒暑假回家，我们都会有聚一聚，友情如故，大家一起聊聊大学的一些事和感受,我觉得这样挺好的。 讲真，王安石变法那一段关于政治和经济局势的部分，看不太懂.... ","date":1544752017,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1544752017,"objectID":"c8dcd9ae4a8f815c86da39fc398539a3","permalink":"https://kangzhiqing.com/life/dongpo/","publishdate":"2018-12-14T09:46:57+08:00","relpermalink":"/life/dongpo/","section":"life","summary":"和林语堂先生在《苏东坡传》开篇写的那样，我写这篇读后感并没有什么特别的理由，只是以此为乐而已，且此篇读后感和以往写的不同，算是一篇读书笔记吧","tags":null,"title":"林语堂《苏东坡传》读后感","type":"life"},{"authors":null,"categories":null,"content":" 在学习node的时候，进行连接数据库相关操作，于是就学习了一下mongodb非关系型数据库。 mongodb操作的都是对象\n基本命令汇总 show dbs 显示所有的数据库 show tables 显示当前数据库下的所有表 db 显示当前数据库 use mydb 切换到mydb数据库，如果没有则创建mydb数据库 db.stu.insert({}) 向stu表中插入数据，如果没有stu则创建一个stu表 db.stu.find() 显示stu表下的所有数据 db.stu.find({条件1},{条件2}) 查找满足条件1且条件2的数据 db.stu.find({$or:[{条件1},{条件2}]}) 查找满足条件1或条件2的数据 db.stu.find({age:{$gte:10,$lte:20}}) 查询stu表中age大于等于10并且小于等于20的数据  ","date":1544515609,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1544515609,"objectID":"9e5df23d090bd250c683f6ed8f290730","permalink":"https://kangzhiqing.com/post/mongodb/","publishdate":"2018-12-11T16:06:49+08:00","relpermalink":"/post/mongodb/","section":"post","summary":"在学习node的时候，进行连接数据库相关操作，于是就学习了一下mongodb非关系型数据库。 mongodb操作的都是对象 基本命令汇总 show dbs 显示","tags":["数据库","非关系型","MongoDb"],"title":"Mongodb","type":"post"},{"authors":null,"categories":null,"content":" 之所以用别人造好的轮子，就是觉得自己的设计水平很差，脑子也没有很多的样式储备，写出来的样式有点丑，于是乎就想用一用类似BootStrap、uiket等轮子库，借鉴一下。这里就先学习了一下element-ui，，看！别人的轮子又大圆~\n基本介绍 Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库 现在是vue3.0，估计一段时间之后就会变成3.0了，相应的改动也会更新\nVue-cli@3.0使用element-ui 作为一个插件添加到vue-cli中\nvue create el cd el vue add element  安装element插件过程中会有交互，是全部导入，还是按需求导入，我是选择按需求导入，这样比较方便，也比较轻。 成功之后就可以看到你的vue-cli初始页面就会有一个element-button\nelement.js import Vue from 'vue' import { Button } from 'element-ui' import 'element-ui/lib/theme-chalk/index.css' Vue.use(Button)  tip：一定要导入对应你需要的css样式，这样才有用,index.css是theme-chalk下所有的css入口文件，如果只想单独使用某个css，找到那个css导入就好了 选择你需要的轮子 官网有很详细的介绍和样式预览，选择需要的，然后使用就好了，对于很好的样式可以看一看具体css怎么实现的，增加一些自己写css的能力\nFAQ  vue使用element-ui的el-input监听不了回车事件解决 在后面加个native @keydown.enter.native  ","date":1543931267,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543931267,"objectID":"8cbd5f9e87a1aaf4bcab88694f99f0e0","permalink":"https://kangzhiqing.com/post/element-ui/","publishdate":"2018-12-04T21:47:47+08:00","relpermalink":"/post/element-ui/","section":"post","summary":"之所以用别人造好的轮子，就是觉得自己的设计水平很差，脑子也没有很多的样式储备，写出来的样式有点丑，于是乎就想用一用类似BootStrap、u","tags":["element-ui","轮子库"],"title":"Element Ui","type":"post"},{"authors":null,"categories":null,"content":" 坑 在使用axios拦截器的时候，在vue-router的钩子函数created是不会触发的\nscroll 在写websocket网页版聊天时，有个需求时每次发消息，scroll都要定位在最下面，刚开始我是监听一个data里message数据的变化，每次有消息的时候，元素的scrollTop=元素的scrollHeight，但每次都是滚动条都定位在最底下的上一条消息上，因为每有一个消息，我就push到message的数组里面，然后页面自动渲染，也就是在最后一条消息渲染完成前就完成了滚动条的移动，所以导致每次都差一条消息的位置。解决办法就是监听dom的变化， 使用this.$nextTick()，dom变化后再进行滚动条的移动\n只能点击一次事件 v-click.once=\u0026ldquo;clickOnce\u0026rdquo;\n","date":1543918874,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543918874,"objectID":"8af62db9ab845536c48c82bf65cd894a","permalink":"https://kangzhiqing.com/post/vue/","publishdate":"2018-12-04T18:21:14+08:00","relpermalink":"/post/vue/","section":"post","summary":"坑 在使用axios拦截器的时候，在vue-router的钩子函数created是不会触发的 scroll 在写websocket网页版聊天时，有个需求时每","tags":["vue"],"title":"Vue","type":"post"},{"authors":null,"categories":null,"content":" Header Header #fbfbfb Table 偶数行：#ddd; 单行: #fff; Font Border Border 很淡的那种 #f4f4f4 a #42b983\nbox-shadow rgba(0, 0, 0, 0.12/0.24) Button rgb(233,104,107)\n","date":1543914506,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543914506,"objectID":"0fa87437f236ce950b95a720dbb481e7","permalink":"https://kangzhiqing.com/post/somestyle/","publishdate":"2018-12-04T17:08:26+08:00","relpermalink":"/post/somestyle/","section":"post","summary":"Header Header #fbfbfb Table 偶数行：#ddd; 单行: #fff; Font Border Border 很淡的那种 #f4f4f4 a #42b983 box-shadow rgba(0, 0, 0, 0.12/0.24) Button rgb(233,104,107)","tags":["style"],"title":"SomeStyle","type":"post"},{"authors":null,"categories":null,"content":" 记录学习docker的过程\n特性 标准化 加速开发和构建流程，方便测试。容器可以在开发环境构建，轻松的提交到测试环境，并最终进入生产环境\ndocker核心组件  docker客户端和服务器（C/S）：docker引擎 docker镜像 仓库Registry docker容器  安装 按照官网给的步骤一步一步来就好了 https://docs.docker.com/install/\n启动 $ systemctl start docker  运行一个容器 $ docker run -i -t centos /bin/bash  -i 开启标准输入(STDIN) -t 分配伪tty终端 设置了这两个参数就创建了一个我们可以交互的容器\n附着到正在运行的容器 $ docker attach containerId/Name  删除容器 删除一个容器 $ docker rm containerId/Name 删除所有容器(-q是只显示容器id) $ docker rm `docker ps -a -q`  镜像 拉取镜像\n$ docker pull imageName:version  删除镜像\n$ docker rmi imageName:version/id  查看镜像详细信息\n$ docker inspect repositoryName/imageId  将镜像推送到Docker Hub 登录\n$ docker login Username:~ Password:~  推送\n$ docker push Username/~:tag push到远程仓库的镜像名必须是用户名开头的镜像，如果不是会被拒绝，改下镜像名字就好了 $ docker tag imageId Username/~:tag  创建镜像 commit命令创建镜像\n$ docker commit containerId/Name respositoryPath  Dockerfile创建镜像\n$ mkdir buildEnv $ cd buildEnv $ touch Dockerfile $ vim Dockerfile # Dockerfile # 指定基础镜像(base image) FROM ubuntu:latest # 申明作者以及邮箱 MAINTAINER Name \u0026quot;Email\u0026quot; # 执行RUN指令 RUN apt-get update \u0026amp;\u0026amp; apt-get install -y nginx RUN echo 'hello world' \u0026gt;/usr/share/nginx/html/index.html # 暴露端口 EXPOSE 80 $ docker build -t=\u0026quot;kzq/nginx\u0026quot; . 启动镜像 $ docker run -d -p 80 \u0026quot;kzq/nginx\u0026quot; nginx -g \u0026quot;daemon off;\u0026quot; // -d以分离（detached）的方式在后台运行 -p公开端口给宿主机  自动化工具docker-compose Compose is a tool for defining and running multi-container Docker applications Compose是一个用于定义和运行多容器Docker应用程序的工具\n 安装 话不多说，官网文档大法好 https://docs.docker.com/compose/install/ 三步走 (1)创建Dockerfile搭建环境 (2)创建docker-compose.yml配置服务 (3)运行docker-compose up docker-compose.yml格式(注意空格)  version: '3' services: web: ports: - \u0026quot;5000:5000\u0026quot; volumes: - .:/code - logvolume01:/var/log links: - redis redis: image: redis  nginx配置 # 用户名 user nginx; # 工作进程数 worker_processes auto; # 错误日志 error_log /var/log/nginx/error.log; # 进程管理 pid /run/nginx.pid; # Load dynamic modules. 加载动态模块 include /usr/share/nginx/modules/*.conf; # events模块，处理连接的设置 events { # 每个进程的最大连接数 worker_connections 1024; } # http服务 http { # 日志格式 log_format main '$remote_addr - $remote_user [$time_local] \u0026quot;$request\u0026quot; ' '$status $body_bytes_sent \u0026quot;$http_referer\u0026quot; ' '\u0026quot;$http_user_agent\u0026quot; \u0026quot;$http_x_forwarded_for\u0026quot;'; # 访问日志 access_log /var/log/nginx/access.log main; # sendfile传输文件系统 # 传统方法：硬盘-\u0026gt;内核缓冲区-\u0026gt;用户缓冲区-\u0026gt;内核socket缓冲区-\u0026gt;协议引擎 # sendfile方法:硬盘-\u0026gt;内核缓冲区-\u0026gt;内核socket缓存区-\u0026gt;协议引擎 # sendfile系统调用DMA引擎直接将文件数据从内核缓存区拷贝到内核socket缓冲区，提高了性能 sendfile on; tcp_nopush on; tcp_nodelay on; # 连接超时时间 keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; server { listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } }  ","date":1543479934,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543479934,"objectID":"8b987a11764fa95fae8b94d2e5213018","permalink":"https://kangzhiqing.com/post/docker/","publishdate":"2018-11-29T16:25:34+08:00","relpermalink":"/post/docker/","section":"post","summary":"记录学习docker的过程 特性 标准化 加速开发和构建流程，方便测试。容器可以在开发环境构建，轻松的提交到测试环境，并最终进入生产环境 docke","tags":["docker"],"title":"Docker","type":"post"},{"authors":null,"categories":null,"content":"需要写一些关于C的实验报告，老师给的VC++6.0感觉很难用(字体小而且难看)，于是乎就想用我经常用的vscode编辑器来写C，上网百度了一些教程，搞了半天都没怎么搞懂里面的配置，于是自己就捣鼓了一哈。\n 在vscode下载C/C++(Microsoft)扩展 下载编译器tdm-gcc(windows),其他编译器具体请看对应的官网，我觉得这个比较容易装就装了这个。 安装成功会自动到将tdm-gcc的bin路径加入到windows的path变量中，如果没有则自己手动添加一下  基本上做完上面两步就可以了 直接在终端输入gcc file.c -o file.exe就编译好了。 还有一种简单的方法就是在VScode中安装一个扩展插件\u0026ndash;Code Runner,这是一个可以运行C，C++，java，JS，PHP，Python的一个插件,安装好了重新加载一下就会看到在VScode右边出现一个运行的按钮,不过默认是在输出下运行，不过输出是一个只读编辑器,所以如果有scanf需要输入的话就不能做了。这时候改下Code Runner的配置，使它运行在Terminal。 文件\u0026ndash;\u0026gt;首选项\u0026ndash;\u0026gt;设置\u0026ndash;\u0026gt;用户设置\u0026ndash;\u0026gt;扩展\u0026ndash;\u0026gt;Code Runner Configuation\u0026ndash;\u0026gt;勾选✔Run in Terminal 还有一个问题就是运行C的时候中文在Terminal中使会乱码的，这是因为cmd自身编码的问题, 解决办法是终端或者在CMD.exe中进入到当前文件目录下输入chcp(CHCP是一个计算机指令，能够显示或设置活动代码页编号), 默认应该是936简体中文，所以需要改为utf-8，utf-8代码页编号是65001，输入chcp 65001就好了\n","date":1543315166,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543315166,"objectID":"229bd06f5a62231c6be9baa43a2587c8","permalink":"https://kangzhiqing.com/post/vscode_c/","publishdate":"2018-11-27T18:39:26+08:00","relpermalink":"/post/vscode_c/","section":"post","summary":"需要写一些关于C的实验报告，老师给的VC++6.0感觉很难用(字体小而且难看)，于是乎就想用我经常用的vscode编辑器来写C，上网百度了一","tags":["vscode","C环境"],"title":"VScode配置C环境","type":"post"},{"authors":null,"categories":null,"content":" 开此篇记录下学习node的过程和一些笔记\n 事件驱动、非堵塞、单线程 Node.js是一个非阻塞的系统，当调用一些需要阻塞的等待或者事件，node会采用回调函数替代闲置等待，即事件驱动。就像我们在学校经常吃饭点餐的情况，点完餐之后店家会给个小票，上面有这此点餐的号码，到时候菜做好了就会叫号，这个号码相当于回调号码，这样就提高了效率，继续为下一个客人服务。 串行IO和并行IO，类似于同步和异步，前者的运行顺序是固定的，后者任何一个IO操作返回时间都是不确定的，如果IO操作有关联的话就要使用串行IO。按顺序的串行请求，无序的并行的请求  files // ---------files--------- // 引入模块 var fs = require('fs'); // 1.写文件，当前路径下没有就创建一个，如果存在就覆盖 fs.writeFile('./test.txt', '异步写入一些数据', 'utf8', function(err){ if(err){ console.log('写入失败') throw err }else{ console.log('写入成功') } }) fs.writeFileSync('./test.txt','同步写入一些数据','utf8') // 2.读文件，如果不加编码类型，则data返回的就是一个buffer缓冲区，里面存有二进制数据 fs.readFile('./test.txt','utf8',function(err, data){ console.log(data) }) // 3.追加文件，如果没有则创建一个 fs.appendFileSync('./log.txt', '同步追加，写入时间：'+new Date().toLocaleString()+'\\n') fs.appendFile('./log.txt','异步追加，写入时间：'+new Date().toLocaleString()+'\\n',function(err){ if(err){ console.log('添加失败') }else{ console.log('添加成功') } }) // 4.监听文件，文件只要修改了就会执行回调函数 fs.watchFile('./log.txt', function(cuur,prev) { console.log(prev); }) // 5.判断文件是否存在，存在返回true，不存在返回false var res = fs.existsSync('/a'); console.log(res); fs.exists('./a',function(res){ if(res){ console.log('文件存在') }else{ console.log('文件不存在') } })  http // --------------http----------------- var http = require('http'); var fs = require('fs') // 创建服务 var myServer = http.createServer(function(req, res){ var reqUrl = req.url=='/'?'./html/index.html':'./html'+req.url; if(fs.existsSync(reqUrl)){ var html = fs.readFileSync(reqUrl); res.write(html); }else{ var errPage = fs.readFileSync('./html/404.html'); res.write(errPage); } res.end(); }) // 监听 myServer.listen('1313', function(err){ if (err){ console.log('监听失败') throw err }else{ console.log('服务器已经开启，端口号为：1313') } })  path // --------path------------ var path = require('path'); // 当前文件夹路径 console.log(__dirname) // 当前文件路径 console.log(__filename) // 路径的字符串拼接 var url = path.join('html', 'index.html'); console.log(url)  Express框架 // --------express框架---------- var express = require('express'); var path = require('path'); // 实例化对象 var app = express(); // 路由传参 app.get('/student/:id', function(req,res){ var id = req.params.id; console.log(id); }) // 客户端所有请求 app.all('/all', function(req, res){ res.send('所有的请求都接受了'); }) // 客户端get请求 app.get('/account', function(req, res){ res.status(200).json({ code:0, data:{ name:'kzq', age:20 }, message:'ok' }) }) // 设置访问页面(默认index.html) app.use(express.static(path.join(__dirname,'html'))) app.use('/hello', function(req, res){ res.status(200).sendFile(path.join(__dirname, 'html', 'hello.html')) }) app.use('*', function(req, res){ res.status(404).sendFile(path.join(__dirname, 'html', '404.html')) }) // 监听端口 app.listen(3000, function(err){ if(err){ console.log('监听失败'); throw err; }else{ console.log('express搭建的服务器已开启，端口号是3000') } })  ","date":1543309499,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543309499,"objectID":"1f8c22bfe1e373ca565f9a45b1fa3b13","permalink":"https://kangzhiqing.com/post/node/","publishdate":"2018-11-27T17:04:59+08:00","relpermalink":"/post/node/","section":"post","summary":"开此篇记录下学习node的过程和一些笔记 事件驱动、非堵塞、单线程 Node.js是一个非阻塞的系统，当调用一些需要阻塞的等待或者事件，node","tags":["Node"],"title":"Node","type":"post"},{"authors":null,"categories":null,"content":" 2018年7月之前 暑假之前我就一直陆陆续续的接触后端的python语言，爬虫相关的知识\n2018年7月 mysql数据库，scrapy爬虫\n2018年8月 正式进入前端的学习。从基础的HTML，CSS，JavaScript出发，在8月月底模仿京东和淘宝写了两个没有数据交互的页面，只能说有些僵硬，没有后台的数据，那些二级菜单的商品数据都是自己写的，挺多的。\n2018年9月 开始学习使用vue框架，用vue框架和室友一起合作写了一个监控系统。\n2018年10月 主要都在看一些书，巩固一些JavaScript的知识\n2018年11月 要做一个我们寝室的照片墙，学习了three.js 学three.js的时候，遇到一个坑就是一定要注意camera的位置，因为所有屏幕的图像都是从camrea中看到的，如果camera的位置设置的不好，物体就很难看到，屏幕就会是一团黑色的，我刚开始以为是哪里出了问题，找了半天没找出问题，后面一看camera的position有问题，导致图像看不到了。包括controls的minDistance也要注意不要太大，太大会导致图像只能到一小点，误以为没有，其实是该参数设置太大了\n2018年12月 这个月呢，本专业的考试提前考了，所以前半个月都在准备期末考试，后面用vue写了一个圣诞活动的手机端页面，天使和国王，实现愿望的一个简单的活动页面，挺开心的，班上有一半多都参加了，嘻嘻，第一次自己写的页面有这么多人看，还是比较开心的，不过写这个页面也发现自己对手机端的适配的问题还不是很了解，后期还是要好好学习一下。 tips:2018年度总结我单独写了一篇 =\u0026gt; 2018年度总结\n2019年1月 准备期末考试\n2019年2月 入了个webpack的门，还有很多训练没做\n决定考研=\u0026gt; 开了一篇专门记录考研的博客 传送门\n","date":1542759603,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1542759603,"objectID":"305b221ee64ece57729dbbc5a0d04d98","permalink":"https://kangzhiqing.com/study/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/","publishdate":"2018-11-21T08:20:03+08:00","relpermalink":"/study/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/","section":"study","summary":"2018年7月之前 暑假之前我就一直陆陆续续的接触后端的python语言，爬虫相关的知识 2018年7月 mysql数据库，scrapy爬虫 201","tags":null,"title":"学习过程记录","type":"study"},{"authors":null,"categories":null,"content":" tween.js - http://github.com/sole/tween.js JavaScript tweening engine for easy animations, incorporating optimised Robert Penner\u0026rsquo;s equations. JavaScript补间引擎，可轻松制作动画，并采用优化的Robert Penner方程。\n1.基本用法(Usage) // 开始位置 var InitPosition = {x:100,y:0}; // 目标位置 var targetPosition = {x:200,y:0}; // 创建一个开始位置的tween var tween = new TWEEN.Tween(Initposition); // 告诉tween需要变换到的位置和时间 tween.to({targetPositon},time); // 开始这个动画 tween.start(); // 为了使动画尽可能平滑,可以在每次循环的时候更新tween animate(); function animate() { requestAnimationFrame(animate); //... TWEEN.update(); //... } // 整个变换过程中是不能看到位置的变换的,如果需要可以执行以下代码 tween.onUpdate(function() { console.log(this) })  ","date":1542511368,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1542511368,"objectID":"d1af2ec59127379bfe8167c9b562983b","permalink":"https://kangzhiqing.com/post/tweenjs/","publishdate":"2018-11-18T11:22:48+08:00","relpermalink":"/post/tweenjs/","section":"post","summary":"tween.js - http://github.com/sole/tween.js JavaScript tweening engine for easy animations, incorporating optimised Robert Penner\u0026rsquo;s equations. JavaScript补间引擎，可轻松制作动画，并采用优化的Robert Penner方程。 1.基本用法(Usage","tags":["tween.js","tween","动画"],"title":"Tween.js","type":"post"},{"authors":null,"categories":null,"content":"Linux基本操作 ls -ah 查看所有文件,包括隐藏文件 pwd print working directory 打印当前路径 mv oldname.js newname.js 重命名 cat 查看当前文件 cp: cp \u0026lt;file\u0026gt; \u0026lt;path\u0026gt; 复制file到path路径 cp \u0026lt;file\u0026gt; \u0026lt;copy_name\u0026gt; 复制file并命名为copy_name,到当前路径 touch \u0026lt;file\u0026gt; 创建一个文件 rm -f \u0026lt;file\u0026gt; 删除一个文件 rm -rf \u0026lt;file package\u0026gt; 删除一个文件夹 uname print system information tty 显示当前终端 tar tar -x 解压 tar -v 显示解压过程 tar -f 要操作的文件名 ----------------------------------------------------------------- git基本操作 git是分布式版本控制系统 git 基本操作 git init 初始化仓库 git add \u0026lt;file\u0026gt; 添加file到仓库暂存区 git commit 将暂存区的内容提交到master git status 获取当前的git状态,查看哪些文件操作过 git diff \u0026lt;file\u0026gt; 查看file更改的详细信息 git log 查看当前git的信息 git reset --hard HEAD^ 回退到HEAD之前的一个版本 git reflog 查看提交的不同版本commit号和具体信息 git checkout --\u0026lt;file\u0026gt; 还没有进行git add \u0026lt;file\u0026gt;的操作,回退该文件最近提交的一个版本 git reset HEAD \u0026lt;file\u0026gt; 进行了git add \u0026lt;file\u0026gt;的操作,先进行该步操作,然后再使用git checkout --\u0026lt;file\u0026gt; git rm 删除一个仓库的文件并且提交git commit ssh-keygen -t rsa -C \u0026quot;youremail@example.com\u0026quot; 查看本地的ssh git remote add origin \u0026lt;github上创建的目录的ssh\u0026gt; 远程连接库和本地库 git push -u origin master 将本地的文件全部上传到远程仓库中 之后可以直接用git push 上传文件 在git push的时候寝室断电了怎么办? 断电导致reference broken，commit操作和push操作都会出现问题。最好的办法就是把.git文件删除重新git init一下之后再进行操作 .gitmodules =\u0026gt; git submodules update --init 查看GitHub上的html文件 加上前缀http://htmlpreview.github.io/? ------------------------------------------------------------------ nginx nginx.conf 配置文件 nginx -s reload 重启nginx 123  \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-windows快捷键\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; alt + 鼠标双击图片 显示图片属性 alt + D 浏览器中聚焦到输入框\n","date":1542433787,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1542433787,"objectID":"fe3697195af2e586ab94755a19f8fb97","permalink":"https://kangzhiqing.com/post/command/","publishdate":"2018-11-17T13:49:47+08:00","relpermalink":"/post/command/","section":"post","summary":"Linux基本操作 ls -ah 查看所有文件,包括隐藏文件 pwd print working directory 打印当前路径 mv oldname.js newname.js 重命名 cat 查看当前文件 cp: cp \u0026lt;file\u0026gt; \u0026lt;path\u0026gt; 复制file到path路径 cp \u0026lt;file\u0026gt; \u0026lt;copy_name\u0026gt; 复制f","tags":["command","git","linux"],"title":"Command","type":"post"},{"authors":null,"categories":null,"content":" 1.scene 场景 scene就是一个可以放置物体、灯光的3D空间，和现实中的一个空间相似，可大可小\n//创建一个场景 var scene = new THREE.Scene();  2.camera 相机 camera决定看一个物体的方式和位置，和现实中的相机行为相似，有很多种类的相机。\n PerspectiveCamera 透视相机  // 透视相机更加接近于现实中我们看物体的视角，远小近大 // 创建一个透视相机 var camera = new THREE.PerspectiveCamera(fov可视角度,aspect纵横比,near近端距离,far远端距离) // 设置camera的位置 camera.set(x,y,z)  3.渲染器  WebGLRenderer  var renderer = new THREE.WebGLRenderer()  4.几何形状  立方体(CubeGeometry)  CubeGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) // width,height,depth是分别在x,y,z方向上的长度,后面三个参数是对应的分段数,如果不需要分段可以不设置。几何中心在原点   平面(PlaneGeometry)  长方形平面,并非是无限延伸的平面\nPlaneGeometry(width, height, widthSegments, heightSegments) // width,height分别是x,y方向上的长度,后面两个参数是对应的分段数   球体(SphereGeometry)  SphereGeometry(radius, segmentsWidth, segmentHeight, phiStart, phiLength, thetaStart, thetaLength) // radius:半径,segmentWidth:纬度上切片数,segmentHeight:经度上的切片数,phiStart:经度开始的弧度,phiLength:经度跨过的弧度,thetaStart:纬度开始的弧度,thetaLength:纬度跨过的弧度   文字形状   使用额外的文字形状需要下载和引用额外的字体库,下载对应的json文件放在目录下,用下面的方法引用 传送门:https://github.com/mrdoob/three.js/tree/master/examples/fonts\nvar loader = new THREE.FontLoader(); loader.load('../gentilis_regular.typeface.json', function(font) { var text = new THREE.Mesh( new THREE.TextGeometry('KZQ',{ font:font, size:1, height:1 }), new THREE.MeshNormalMaterial(); scene.add(text); renderer.render(scene, camera); ) })  4.物体  Mesh 构造器  // 基于以三角形为polygon mesh多边形网格的物体的类 Mesh(geometry:Geometry,material:Material)   Object3D()  Object3D是大部分物体的基类，大部分的物体都可以通过Object3D构建\nvar object = new Object3D();  5，加载器  ImageLoader  // 初始化一个加载器 var loader = new THREE.ImageLoader(); // 加载一个图片资源 loader.load( // 资源URL './image/1.jpg', // onLoad回调 function(image){ var canvas = document.createElement('canvas'); var context = canvas.getContext('2d'); context.drawImage(image,100,100) } )  6.控制器  OrbitControls   // 构造器(Constructor) var controls = new THREE.OrbitControls(object:camera,domElement:HTMLDOMElement); // 属性(Properties) 1 .maxDistance 滚轮能放大的最大距离 2 .minDistance 滚轮能缩小的最小距离 // 方法(methods) 1 .update() 更新控件,一般用在手动更新camera变换后调用,或者在更新循环中调用 var controls = new THREE.OrbitControls(camera,renderer.domElement); camera.position.set(0,0,5000); controls.update() function animate(){ requestAnimationFrame(animate); controls.update() }   TrackballControls  球形控制器，以物体为中心，鼠标左键控制旋转，右键平移\n// 构造器(Constructor) var controls = new THREE.TrackballControls(camera, renderer.domElement)  8.其他  Vector3 3D矢量  var vector = new THREE.Vector3(x,y,z); // 如果没有参数，则是指向一个(0,0,0)的矢量;  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;使用three.js创建一个球\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;three.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;OrbitControls.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; // 创建一个场景 var scene = new THREE.Scene(); // 创建一个透视视图相机 var camera = new THREE.PerspectiveCamera(45,window.innerWidth/innerHeight,1,1000); // 设置相机的位置(x,y,z) camera.position.set(0,0,5); // 创建一个渲染器 var renderer = new THREE.WebGLRenderer(); // 设置渲染器的大小 renderer.setSize(window.innerWidth,window.innerHeight); // 设置背景颜色 renderer.setClearColor(0xfff6e6) // 插入到页面当中 document.body.appendChild(renderer.domElement); // 开始渲染(表演开始....) // 创建一个球使用SphereGeometry() var geomery = new THREE.SphereGeometry(1,22,22); // 选择材料 var material = new THREE.MeshNormalMaterial({wireframe:true}); // 创建网格对象 var sphere = new THREE.Mesh(geomery, material); // 加入到场景(舞台)当中 scene.add(sphere); // 创建一个控制器 var controls = new THREE.OrbitControls(camera,renderer.domElement); controls.addEventListener('change',function(){ renderer.render(scene,camera) }) // 渲染 renderer.render(scene,camera) // var animation = function(){ // requestAnimationFrame(animation); // sphere.rotation.x += 0.01; // sphere.rotation.y += 0.01; // renderer.render(scene,camera) // } // animation() \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  ","date":1542383032,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1542383032,"objectID":"e45467cc2b9bc31e09fb9ac07d0a11e9","permalink":"https://kangzhiqing.com/post/threejs/","publishdate":"2018-11-16T23:43:52+08:00","relpermalink":"/post/threejs/","section":"post","summary":"1.scene 场景 scene就是一个可以放置物体、灯光的3D空间，和现实中的一个空间相似，可大可小 //创建一个场景 var scene = new THREE.Scene(); 2.camera 相机 camera决定看一个","tags":["THREE","three","three.js","3D"],"title":"Three.js","type":"post"},{"authors":null,"categories":null,"content":" 1. return !1 和 return false 以及 return 0! 和 return true写法有什么区别 tween.min.js的源码 update: function(c) { if (0 === a.length) return !1; for ( var b = 0, d = a.length, c = void 0 !== c ? c : Date.now(); b \u0026lt; d; ) a[b].update(c) ? b++ : (a.splice(b, 1), d--); return !0; }  2. void 和 undefined 有什么区别(详细请看这里) A : void是一种操作符,无论void后的表达式是什么，void操作符都会返回undefined.但undefined不是保留字,undefined可以作为变量使用,所以在使用undefined作为变量名的时候容易出错,因此使用void可以确保取到undefined值\nfunction x() { var undefined = 'hello world', f = {}, window = { 'undefined': 'joke' }; console.log(undefined);// hello world console.log(window.undefined); //joke console.log(f.a === undefined); //false console.log(f.a === void 0); //true }   void还有一个经常使用到的作用,就是在a标签的href中使用,填充href,使它不跳转而是进行一些交互,比如在许多网站中的收藏,快转功能.  \u0026lt;a href=\u0026quot;javascript:void(0)\u0026quot;\u0026gt;   生成一个空的src的img标签的最好的方式似乎是使用src=\u0026quot;javascript:void(0)\u0026quot; 详情请看What\u0026rsquo;s the valid way to include an image with no src?  \nTip : 关于此问题更加详细请看这里\n3.null!=a 和 a!=null的区别 4.常见的获取元素宽高的方式及其区别  dom.style.width/height 这种方式只能获取dom元素内联样式的宽高，而style标签的样式和外联样式使获取不到的。修改样式用这个还是可以的 dom.currentStyle.width/height 无论哪种样式都可以获得，不过只有IE浏览器支持(我亲测了chrome和firefox都是不兼容的)。只读 window.getComputedStyle(element,[preudoElt]).width/height 首先getComputedStyle(element,[preudoElt])返回的是一个实时的css属性对象preudoElt是伪元素(可选),对于普通元素就是设置为null即可。兼容性更好(IE、firefox、chrome都可以)。只读 dom.offsetWidth/offsetHeight 兼容性很好，常用，且返回值是数字，不带单位。只读 dom.getBoundingClientRect().width/height getBoundingClientRect()返回的是一个元素的绝对位置的DomRect对象，里面有top、bottom、left、right、width、height,IE不兼容getBoundingClientRect(),IE兼容getClientRects(),其他浏览器都兼容，返回值是数值，不带单位。只读  \n以上，个人觉得offsetWidth比较方便一些\n5.window.onload和$(document).ready()方法的区别 A：window.onload事件会在页面所有元素加载完成后立即发生。而$(document).ready()是在DOM树加载完毕之后对其进行操作\n6.v-if和v-else使用应该注意什么？  他们必须是兄弟节点！！！ v-else上一个节点必须是v-if！！！   7. 常见的水平居中的方法？  text-align:center; (具有文本特性的元素水平居中,display为inline或者为inline-block) margin:0 auto (块级元素，且自身要有宽度) position:left;left:50%;margin-left:-元素高度/2; (元素高度已知) position:left;left:50%;transform:translateX(-50%); (元素高度未知) display:flex;justify-content:center;\n  8. 常见的垂直居中的方法？ 9. 常见的水平垂直居中的方法？ 10. calc使用注意事项 运算符前后必须要有空格，如calc(100% - 20px);\n11. background-size中cover和contain有什么区别 两者都是等比例缩放。 cover：如果容器的宽高比和照片的宽高比不同，那么图片就会等比例缩放到塞满整个容器，图片多余的部分就会被裁剪 contain：图片等比列缩放至全部都展示出来，所以可能会有留白\n12. js中关系运算符中大于和小于是怎么比较的？  字符串和字符串比较，比较第一个不同的字符的ASCII码 数字和纯数字字符串比较，将纯数字字符串转换为数字比较 数字和非纯数字字符串比较，返回false 特殊字符 null 和 undefined 进行比较的时候，null == undefined，undefined和除了null的其他所有值进行比较都是false  // 关系运算符 和 相等运算符 并不是一个类别的. // 关系运算符,在设计上,总是需要运算元尝试转为一个number . 而相等运算符在设计上,则没有这方面的考虑. // 最重要的一点, 不要把 拿 a \u0026gt; b , a == b 的结果 想当然的去和 a \u0026gt;= b 建立联系. 正确的符合最初设计思想的关系是 a \u0026gt; b 与 a \u0026gt;= b是一组 . a == b 和其他相等运算符才是一组. 比如 a === b , a != b, a !== b . null \u0026gt; 0 // null尝试转型为number，则为0，所以结果是false null \u0026gt;=0 // null尝试转型为number，则为0，所以结果是true null == 0 // null在设计上不尝试转型，所以结果是false  关于null的问题，参考了关于这个问题的回答=\u0026gt;传送门\n13.JS引擎中对变量的查询方式LHS和RHS有什么区别？ LHS和RHS是JS引擎的两种查找方式，赋值操作的左侧和右侧 LHS：找到目标，对其赋值，赋值操作的目标 RHS：找到源头，得到ta的原值，赋值操作的源头 不同的查找方式结果不一样，如果查找到最顶层的全局作用域下也没有找到变量的话，RHS查找就会抛出异常，而LHS查找方式在非严格模式会在全局作用域隐式的创建该变量，而严格模式则一样会抛出ReferenceError（ES5推出的严格模式不允许自动或者隐式的创建变量） 简单的说就是，如果查找的目的是对变量进行赋值，那么就会使用LHS查询，如果目的是获取变量的值，就会使用RHS查询。\n14.什么是闭包？ 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。函数的执行期上下文没有被销毁\n15.Object.create(null)和{}创建空对象的方式有什么区别？ Object.create(null)创建的对象比{}更‘空’，因为前者是没有创建Object.prototype原型的，而{}则会创建这个原型。\n16.如何判断this指向？ 1.由new调用？绑定到新创建的对象 2.由call或者apply或者bind调用？绑定到指定的对象 3.由上下文对象调用？绑定到那个上下文对象 4.默认：在严格模式下绑定到undefined，非严格模式绑定到全局对象\n17.什么是事件冒泡和捕获？一个事件的执行顺序是怎样的？ 事件冒泡和捕获都是事件的执行顺序，事件捕获是从上到下依次执行，而事件冒泡是从下到上执行。DOM事件流分三个阶段：捕获阶段=\u0026gt; 目标阶段（真正的目标节点正在处理事件的阶段） =\u0026gt; 冒泡阶段，就好比猛地将一个瓶子扔到水里，它会下沉一段距离，然后再浮上来。\n18.什么是事件委托？有什么用？ 事件委托是利用事件冒泡的原理，避免过多的操作DOM元素，利用其父级元素完成相应的事件操作。优化页面。\n19.addEventListener 和 onclick一类 绑定事件有什么区别？  addEventListener可以给一个事件绑定不同的监听器，而onclick一类只能一个事件只能绑定一个，同时绑定多个会覆盖。 addEventListener更加灵活，可以选择事件执行顺序是冒泡（第三个参数为false）还是捕获（第三个参数为true）  20. proto 和 prototype有什么区别？ 21. instanceof的用法？ 22. 常见js迭代器？  forEach some every for\u0026hellip;in 遍历索引 for\u0026hellip;of 遍历元素  23.LF 和 CRLF 换行符有什么不同? 一些题目 1 关于this指向\n// this指向的是调用它的对象，如果没有直接调用对象，会指向undefined或者window，一般都会指向window，在严格模式下才会指向undefined function a(xx){ this.x = xx; return this; }; var x = a(5); // window.x = 5 , return this, x = window var y = a(6); // window.x = 6 , return this, y = window console.log(x.x); // x = 6 , x.x =\u0026gt; undefined console.log(y.x); // y = window , widow.x = 6 // -----------------分割线----------------------- var name = '222'; var a = { name:'111', say:function(){ console.log(this.name); //谁调用this就指向谁 } } var fun = a.say; fun(); // this指向window, this.name = '222' a.say(); // this指向a, this.name = '111' var b = { name:'333', say:function(fun){ fun(); } } b.say(a.say); // say:function(fun){ // this;这里的this指向b // fun(); fun里面的this是在预编译过程中指向window的 //} // 所以这里的this.name = '222' fun() // this指向window, this.name = '222' b.say = a.say; b.say(); // this.name = '333' // -------------------分割线-------------------- function Point(x, y){ this.x = x; this.y = y; this.moveTo = function(x, y){ this.x = x; this.y = y; console.log(this.x + \u0026quot;,\u0026quot; + this.y); } } var p1 = new Point(0,0); var p2 = {x:0,y:0}; p1.moveTo(1,1); // 1,1 p1.moveTo.apply(p2,[10,10]); // 10,10 // -------------------分割线--------------- var num = 10; var obj = { num:0, inner:{ num:6, print:function(){ console.log(this.num); } } } num = 88; // 全局num变为88 obj.inner.print() // 6 var fn = obj.inner.print; fn(); // 88 (obj.inner.print)(); // 6 (obj.inner.print = obj.inner.print)(); // 0  ","date":1542333679,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1542333679,"objectID":"927258eba94b3d941902e01f348a90fc","permalink":"https://kangzhiqing.com/post/questions/","publishdate":"2018-11-16T10:01:19+08:00","relpermalink":"/post/questions/","section":"post","summary":"1. return !1 和 return false 以及 return 0! 和 return true写法有什么区别 tween.min.js的源码 update: function(c) { if (0 === a.length) return !1; for ( var b = 0, d = a.length, c = void 0 !== c ? c : Date.now(); b \u0026lt; d; )","tags":["Question"],"title":"Q \u0026\u0026 A","type":"post"},{"authors":null,"categories":null,"content":" perspective 设置元素被查看位置的视图\ndiv{ perspective:500px; }  ","date":1541078542,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1541078542,"objectID":"a8face6dc9bf3e1e75afb9c8348bcede","permalink":"https://kangzhiqing.com/post/css3property/","publishdate":"2018-11-01T21:22:22+08:00","relpermalink":"/post/css3property/","section":"post","summary":"perspective 设置元素被查看位置的视图 div{ perspective:500px; }","tags":["CSS","property"],"title":"Css3Property","type":"post"},{"authors":null,"categories":null,"content":" typeof返回一个字符串,表示为经计算的操作数的类型 typeof(操作数)/typeof 操作数 ()是可以省略的 返回有五种基本类型:string,number,boolean,undefined,function,object 还有ES6的Symbol\n// 1.string: typeof('你好') typeof('123') typeof('') // 空字符串也是String类型 typeof(typeof('a')) // 2.number: typeof(123); typeof(NaN); // 3.boolean: typeof(true); typeof(false); typeof(NaN===NaN) // 强制类型转换 // 4.undefined: typeof(a) // 未经使用的变量的数据类型 // 5.object: typeof(null) // js底层所有值的前三位表示数据类型,object是000,而null的32位全是0,因此也是object typeof([]) typeof({}) // 6.function: typeof(function(){}) typeof(new Function()) typeof(class A{}) typeof(Symbol) // 7.symbol: typeof(Symbol())  暂时性死区 在ES6中let和const出现之前,typeof都是一个完全安全的操作,即不会报错,但有了ES6中let和const的出现所带来的暂时性死区特性,使得typeof也有可能报错\n如果在一个块级作用域下存在let或const命令,则它所声明的变量就绑定在这个区域,不再受外部的影响.在声明之前使用这些变量就会报错.使用let命令声明变量之前是不可用的,这在语法上称为暂时性死区\ntypeof(a); //ReferenceError let a;  ","date":1541065939,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1541065939,"objectID":"1d830bace5d0c7993468566a34f4c9a0","permalink":"https://kangzhiqing.com/post/typeof/","publishdate":"2018-11-01T17:52:19+08:00","relpermalink":"/post/typeof/","section":"post","summary":"typeof返回一个字符串,表示为经计算的操作数的类型 typeof(操作数)/typeof 操作数 ()是可以省略的 返回有五种基本类型:stri","tags":["JS"],"title":"Typeof","type":"post"},{"authors":null,"categories":null,"content":" Canvas 是 HTML5 新增加的一个元素,它又称为\u0026rdquo;画布\u0026rdquo;,主要有以下四种功能\n 绘制图形 绘制图表 动画效果 游戏开发  在 chrome 浏览器中,canvas 的默认宽高是 300px 和 150px,写宽高的样式的时候最好写在 HTML 页面的属性值里面\n\u0026lt;canvas width=\u0026quot;150\u0026quot; height=\u0026quot;100\u0026quot; style=\u0026quot;border: 1px black dashed\u0026quot;\u0026gt;\u0026lt;/canvas\u0026gt;  一般的操作 1.获取 canvas 对象 2.获取上下文环境对象 context\ncxt = canvas.getContext(\u0026quot;2d\u0026quot;);  3.开始绘制图形\n1.直线 cxt.moveTo(x1,y1) 画笔移到(x1,y1)处 cxt.LineTo(x2,y2) 画笔从起点(x1,y1)开始画线,一直到终点(x2,y2)处 cxt.strokeStyle = \u0026quot;red\u0026quot; 设置线的颜色 cxt.stroke() 用笔划线 (tip:cxt.strokeStyle要在cxt.stroke()之前执行,否则是看不到效果的,和画画是一样的,在动笔之前把要画的东西,颜色,样式确定好  2.描边矩形 填充矩形 清空矩形  描边矩形  cxt.strokeRect(x1,y1,x2,y2) (x1,y1)为矩形左上角坐标,(x2,y2)为矩形右下角坐标 等价于==\u0026gt; cxt.rect(x1,y1,x2,y2); cxt.stroke();   填充矩形  cxt.fillStyle = \u0026quot;属性值\u0026quot; cxt.fillRect(x1,y1,width,height) (x1,y1)是矩形左上角坐标,width是矩形的宽度,height是矩形的高度 等价于==\u0026gt; cxt.rect(x1,y1,x2,y2); cxt.fill()   清空矩形  cxt.clearRect(x1, y1, x2, y2);   绘制一个正 n 多边形  \u0026lt;canvas width=\u0026quot;100\u0026quot; height=\u0026quot;50\u0026quot; style=\u0026quot;border: 1px black dashed\u0026quot;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;script\u0026gt; var canvas = document.getElementsByTagName('canvas')[0] var cxt = canvas.getContext('2d'); //获取上下文环境对象 var cvs_width = parseFloat(getComputedStyle(canvas, null).width); //获取画布的宽 var cvs_height = parseFloat(getComputedStyle(canvas, null).height); //获取画布的高 var distanceR = distanceD = 0 function createPolygon(n) { var r = Math.min(cvs_width, cvs_height)/2; //正多边形外接圆半径 if(Math.min(cvs_width,cvs_height)==cvs_height){ distanceR = (cvs_width/2) - r }else{ distanceD = (cvs_height/2) - r } var degree = (2 * Math.PI) / n; //每个角的度数 cxt.moveTo(0+distanceR, r+distanceD); //初始化起点 for (let i = 1; i \u0026lt; n; i++) { cxt.lineTo(r - r * Math.cos(i * degree)+distanceR, r + r * Math.sin(i * degree)+distanceD); } cxt.closePath(); cxt.fillStyle = \u0026quot;#f40\u0026quot;; cxt.fill() } \u0026lt;/script\u0026gt;  2.曲线  圆形  cxt.beginPath() 开始一个路径 cxt.arc(x,y,半径,开始角度,结束角度,anticlockwise) // (x,y)时圆心的坐标,开始角度和结束角度都是弧度制,anticlockwise(逆时针地)为true时,逆时针绘制图形,为false时,顺时针绘制图形 cxt.closePath() 结束一个路径 // 描边 cxt.strokeStyle = \u0026quot;颜色值\u0026quot; cxt.stroke() 画线 // 或者填充 cxt.fillStyle() cxt.fill()   弧形  1.arc() // 和画圆基本语法一样,就是把cxt.closePath()去掉就好了 2.arcTo(cx,cy,x2,y2,radius) // 控制点坐标(cx,cy) 终点坐标(x2,y2) radius是圆弧半径 起点坐标(x1,y1)由一般由moveTo()或lineTo()提供   二次贝塞尔曲线  cxt.quadraticCurveTo(cx,cy,x2,y2) // (cx,cy)控制点坐标,(x2,y2)终点坐标,起点坐标由moveTo()或lineTo()提供   三次贝塞尔曲线  cxt.bezierCurveTo(cx1,cy1,cx2,cy2,x,y) //(cx1,cy1)控制点1的坐标,(cx2,cy2)控制点2的坐标,(x,y)表示结束点坐标,起点坐标由moveTo()或lineTo()提供  3.线条操作 lineWidth //线条宽度(px) lineCap //线帽样式 Butt默认值无键帽,Round圆形键帽,Square正方形键帽 lineJoin //线条交接处样式 miter默认值尖角,round圆角,bevel斜角  canvas应用实例 （1）星光闪闪 先上效果 \u0026lt;canvas id=\u0026quot;myCanvas\u0026quot;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;script\u0026gt; // 获取画布 var myCanvas = document.getElementById('myCanvas'); // 画笔 var ctx = myCanvas.getContext('2d'); // 创建一个列表存放位置信息 var list = []; // 初始化画布 function init(){ myCanvas.width = window.innerWidth; myCanvas.height = window.innerHeight; } init(); // 每当窗口大小变化的时候重新初始化 window.onresize = init; // 初始化位置 for(let i=0; i\u0026lt;777; i++){ // 圆点的位置 var x = Math.random() * myCanvas.width; var y = Math.random() * myCanvas.height; // 圆的半径 var r = Math.random() * 5; // 圆的偏移量,发散的移动，以中间为界限，左上的向左上角移动，右上的向右上角移动，左下向左下角移动，右下向右下角移动 var disX = x - myCanvas.width / 2; var disY = y - myCanvas.height / 2; list.push({ x:x, y:y, r:r, disX:disX, disY:disY }); } // 绘制函数 function render(){ // 每次都把画布更新 ctx.clearRect(0,0,myCanvas.width,myCanvas.height); for(var i=0;i\u0026lt;list.length;i++){ var item = list[i]; // 圆点移动 item.x += item.disX / 50; item.y += item.disY / 50 // 判断小圆点消失 if(item.x \u0026lt; 0 || item.y\u0026lt;0 ||item.x\u0026gt;myCanvas.width || item.y \u0026gt; myCanvas.height){ // 每次消失重新生成圆点 item.x = Math.random() * myCanvas.width; item.y = Math.random() * myCanvas.height; item.disX = item.x - myCanvas.width/2; item.disY = item.y - myCanvas.height/2; } // 开始绘制 ctx.beginPath(); // 填充颜色 ctx.fillStyle = \u0026quot;rgb(\u0026quot;+random(0,255)+','+random(0,255)+','+random(0,255)+')'; // 绘制圆 ctx.arc(item.x,item.y,item.r,0,Math.PI*2,false); ctx.fill(); } // 每40毫秒重新绘制 setTimeout(render,40); } render(); function random(left,right){ return Math.random() * (right-left+1) + left } \u0026lt;/script\u0026gt;  ","date":1540983137,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1540983137,"objectID":"d084150bb5d312defc4e3d00117942d2","permalink":"https://kangzhiqing.com/post/canvas/","publishdate":"2018-10-31T18:52:17+08:00","relpermalink":"/post/canvas/","section":"post","summary":"Canvas 是 HTML5 新增加的一个元素,它又称为\u0026rdquo;画布\u0026rdquo;,主要有以下四种功能 绘制图形 绘制图表 动画效果 游戏开发 在 chrome 浏览器中,canva","tags":["CSS","Canvas"],"title":"CSS3 Canvas","type":"post"},{"authors":null,"categories":null,"content":" sam ├─archetypes ├─exampleSite │ ├─content │ │ ├─gallery │ │ │ └─images │ │ │ └─small │ │ └─posts │ ├─resources │ └─static │ └─img ├─images ├─layouts │ ├─gallery │ ├─partials │ ├─posts │ └─_default ├─sass └─static └─css  ","date":1540909347,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1540909347,"objectID":"a6621a83656e41a509da0b68020cc6ed","permalink":"https://kangzhiqing.com/post/sam/","publishdate":"2018-10-30T22:22:27+08:00","relpermalink":"/post/sam/","section":"post","summary":"sam ├─archetypes ├─exampleSite │ ├─content │ │ ├─gallery │ │ │ └─images │ │ │ └─small │ │","tags":["blog","story"],"title":"Hugo主题sam","type":"post"},{"authors":null,"categories":null,"content":" mysql数据库是我今年暑假在家学习的，当时学习的时候写了一些笔记，现在把笔记整理到博客上。\nTips  sql语句的语法Windows下是不区分大小写的，但在Linux是严格区分的，最好还是用大写吧 单双引号表示字符没有区别 注释单行一般用 --，多行（块）用 /* */ 命名规范遵循基本的命名原则，具体因人而异，个人喜欢小驼峰  SQL语句分类  数据库查询语言DQL（datebase query language） SELECT 数据库定义语言DDL（datebase defined language）\nCREATE DATABASE、CREATE TABLE、DROP DATABASE、DROP TABLE 数据库操作语言DML（database manage language）\nUPDATE、INSERT、DELETE  数据类型属性 mysql常见的数据类型：varchar(n)、float、int(n)、bigint(n)、date、datetime、text\n 默认值 default '默认值' 非空：NOT NULL 如果某一个字段别NOT NULL修饰后，添加数据时，此字段必需填写 自动增长：auto_increment，尽量作用在int类型的字段上 主键(唯一的，不能重复，一张表中只能以一个作为主键)：primary key 唯一健（唯一，可以有很多）：unique，被unique修饰的数据不能够重复  一个栗子\nUSE kzq; DROP TABLE students; CREATE TABLE students( id BIGINT(20) AUTO_INCREMENT PRIMARY KEY COMMENT '学生编号', stuName VARCHAR(40) COMMENT '学生姓名', gender VARCHAR(2) DEFAULT '男' COMMENT '性别', className VARCHAR(20) NOT NULL COMMENT '班级', phone VARCHAR(20) UNIQUE COMMENT '手机号码' )  库与表的创建和删除 -- 创建库 CREATE DATABASE 库名 CHARACTER SET 编码名 CREATE DATABASE kzq CHARACTER SET utf8 -- 选中某一个数据库 USE 库名 USE kzq -- 创建表 CREATE TABLE 表名( 字段1 数据类型 COMMENT ....., -- COMMENT为注释（对该字段的具体信息的补充） -- 字段1和字段2之间注意不要漏写逗号',' 最后一个字段结尾没有符号 字段2 数据类型 COMMENT ....., ....... ) CREATE TABLE mysqlScore( stuName VARCHAR(40) COMMENT \u0026quot;学生姓名\u0026quot;, stuClass VARCHAR(20) COMMENT \u0026quot;学生班级\u0026quot;, stuScore FLOAT COMMENT \u0026quot;学生成绩\u0026quot; ); -- 删除库和表 -- 友情提示：删库需谨慎，正所谓MySQL从删库到跑路 DROP DATABASE 库名 DROP TABLE 表名 -- 查看所有库 SHOW DATABASE -- 查看创建库的详细信息 SHOW CREATE DATABASE 库名 -- 查看创建表的详细信息 SHOW CREATE TABLE 表名 -- 查看当前用户连接的是哪个数据库 SELECT DATABASE() -- 查看当前用户连接的库下的所有表 SHOW TABLES -- 查看某一张表的结构 -- DESC =\u0026gt; description DESC 表名  表的增（Create）、删（Delete）、改（Update）、查（Retrieve） 增 USE kzq -- 方法一 INSERT INTO 表名(字段1,字段2....) VALUES(值1,值2) INSERT INTO mysqlScore (stuName,stuClass,stuScore) VALUES ('刘仔','xxx',90.5) -- 在插入时，可以省略掉字段名，但后面的VALUES必须全 INSERT INTO mysqlScore VALUES ('刘仔','xxx',90.5) -- 同时插入多条数据 INSERT INTO mysqlScore (stuName,stuClass,stuScore) VALUES ('刘仔','xxx',90.5),('小刘','xxx',90.6) -- 方法二 INSERT INTO 表名 SET 字段名1=字段值1 INSERT INTO mysqlScore SET stuName='刘仔'  删 -- 如果\u0026quot;=\u0026quot;是放在SET关键字后，则是\u0026quot;赋值运算符\u0026quot; -- 如果\u0026quot;=\u0026quot;是放在WHERE关键字后，则是\u0026quot;关系运算符\u0026quot; DELETE FROM 表名 WHERE 条件 DELETE FROM mysqlScore WHERE stuName='刘仔' -- 如果要删除一整张表中的数据，使用truncate，使用truncate删除数据后，如果字段是自增的、则重新排列 TRUNCATE TABLE students;  改 -- 重命名表名 RENAME TABLE 旧表名 TO 新表名 RENAME TABLE aaa TO bbb; -- 添加字段 ALTER TABLE 表名 ADD 字段名 数据类型 ALTER TABLE person ADD gender VARCHAR(2) -- 删除字段 ALTER TABLE 表名 DROP 被删除字段名 ALTER TABLE person DROP gender -- 重命名字段 ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新字段名数据类型 ALTER TABLE person CHANGE aaa bbb VARCHAR(40) -- 修改数据类型（长度） ALTER TABLE person CHANGE aaa aaa VARCHAR(25)  查 -- 逻辑运算符 与and 或or 非not -------- 基本查询 -------- SELECT 字段1，字段2....FROM 表名 (WHERE 条件) SELECT stuName,stuClass,stuScore FROM mysqlScore; SELECT stuName FROM mysqlScore -- *代表所有字段 SELECT * FROM mysqlScore -- AS是取别名，WHERE后面是条件 SELECT stuName (AS passName) FROM mysqlScore WHERE stuScore\u0026gt;=60; -- 降序(DESC) SELECT * FROM mysqlScore ORDER BY stuScore DESC; -- 升序(ASC) SELECT * FROM mysqlScore ORDER BY stuScore ASC; -------- 聚合函数查询 -------- SELECT 函数名（字段） FROM 表名 -- 找出最大值：max(字段) SELECT MAX(stuScore) AS maxScore FROM mysqlScore; -- 找出最小值：min(字段) SELECT MIN(stuScore) AS minScore FROM mysqlScore; -- 求平均数：avg(字段名) SELECT AVG(stuScore) AS avgScore FROM mysqlScore; -- 求和 sum SELECT SUM(stuScore) AS totalScore FROM mysqlScore; -- 统计记录 count SELECT COUNT(*) FROM mysqlScore -- 常用函数 SELECT NOW() -- 年月日、时分秒 SELECT CURTIME() -- 时分秒 SELECT CURDATE() -- 年月日 SELECT CEIL(2.3) -- 向上取舍 SELECT FLOOR(2.3) -- 向下取舍 SELECT RAND() -- 返回0到1的随机数 -- 时间格式函数 SELECT DATE_FORMAT(DATE,'%Y年%m月%d日 %H:%i:%s') AS birthday FROM persons -------- 查询多条记录和分组查询 -------- -- 多条查询 SELECT * FROM users WHERE id IN (1,3) SELECT * FROM users WHERE id -- 查询是否有种类为衣服的类型 SELECT goodCategory FROM goods GROUP BY goodCategory HAVING goodCategory='衣服' -- 分页查询 -- limit 起始下标,每页显示的数据量 -- goods表中有七条数据记录，每一页显示三条，总共可以分3页 SELECT * FROM goods LIMIT 0,3; -- 第一页 SELECT * FROM goods LIMIT 3,3; -- 第二页 SELECT * FROM goods LIMIT 6,3; -- 第三页 -------- 多表查询 -------- select * from 表1,表2....表n where 条件 /* 多表查询方式： 内连接 外连接 左右连接 右外连接 */ -- 内连接 -- on后面接几个表中有关联的条件，没有关联的条件用where select * from 表1 inner join 表2 on 条件(多个表中有关联的条件) where 没关联的条件 -- 查新所有部门中的所有员工 SELECT * FROM dept d INNER JOIN emp e ON d.id = e.deptId -- 查询在开发部的员工姓名和收入 SELECT d.deptName,e.empName,e.salary FROM dept d INNER JOIN emp e ON d.id = e.deptId WHERE d.dept = '开发部' -- 左外连接 left join 以左边的表为主，左边的表数据要显示出来 -- 右外连接 right join 以右边的表为主，右边的表数据要显示出来 -------- 模糊查询 -------- LIKE 模糊查询 a% -- 以a开头，%为占位符 %a -- 以a结尾 %a% -- 包含a -- 查询中国拍摄的电影的id和title SELECT id,title FROM movies WHERE country LIKE '%中国%'  视图 在真实表上面构建的一张虚表 视图的应用场景：在金融行业，保险行业，财务行业等\nCREATE view 视图名 AS 查询语句; CREATE VIEW view_all AS SELECT e.empName,e.salary,d.deptname FROM dept d INNER JOIN emp e ON d.id = e.deptId; DROP VIEW view_all;  事务 -- 开启事务 START TRANSACTION; -- 回滚事务 ROLLBACK; -- 提交事务 COMMIT;  事务的四大特性  原子性(Atomicity)：多组操作为一个整体，不能分割，全部操作成功才算成功，有一步失败就失败了，一环扣一环。 一致性(Consistency)：操作前后最终的总量一样，比如说转账，两个人相互转账，这两个人无论向对方怎么转，两个人的总钱数是不变，如果变了，就说明失败了。 隔离性(Isolation)：并发(同一时刻多个事务执行)事务之间相互隔离互不干扰。\n 在mysql中事务有4种隔离级别：  read uncommitted(读取未提交) read committed(读取提交) repeatable read(可以重复读) Serializable  查看mysql软件的事务隔离级别 SELECT @@tx_isolation 修改mysql软件默认的隔离级别 set global transaction isolation level 隔离级别 不同的隔离级别会引发不同的问题  当mysql事务的隔离级别为read uncommitted时，会引发脏读(一个事务可以读取另一个事务未提交的数据.)，解决脏读问题可以将数据库事务的隔离级别改为:read committed 当mysql软件的事务隔离级别为:read committed的时候，会引发不可重复读：在同一事物中多次读取的结果不一致如何解决不可重复读：将事物的隔离级别改为repeatable read 当mysql软件的事务隔离级别为:repeatable read时，会引发虚读(幻读)    持久性(Durability)：数据进入到数据库中后，数据会持久存在\n  数据库的备份和还原  命令  备份 mysqldump -u root -p (密码) 需要备份的数据库名\u0026gt;备份后的sql文件名 mysqldump -u root -p (密码) kzq\u0026gt;c:\\kzqBack.sql 还原 进入mysql环境\u0026mdash;-\u0026gt;创建一个库\u0026mdash;-\u0026gt;在库下还原数据 source 备份数据库文件名  软件（图形界面操作sqlyog） 选中需要备份的数据库\u0026mdash;\u0026ndash;\u0026gt;右键\u0026mdash;\u0026mdash;\u0026gt;备份/导出\u0026mdash;-\u0026gt;转储到sql  未整理完的 MySQL存储过程以及一些示例\n笔记原文 DROP DATABASE kzq; #在创建库时，希望制定编码 语法：create database库名 set 编码名 CREATE DATABASE kzq CHARACTER SET utf8; #-----------------------------创建表（table）--------------------------------------------- #创建表语法： CREATE TABLE 表名( 字段1 数据类型 COMMENT .....,#注释 comment 。。。 字段2 数据类型 COMMENT ....., ....... ) # 选中某一个数据库： use 库名； USE kzq; CREATE TABLE java成绩表( 姓名 VARCHAR(40), 班级 VARCHAR(20), Java成绩 FLOAT ); # 删除制定表语法：drop table 表名; DROP TABLE java成绩表; # ------------------------往表中添加、删除、修改、查询数据(CRUD)------------------------------------------- #往置顶的表中添加数据： #第一种方法 insert into 表名(字段1,字段2....) values(值1,值2) INSERT INTO java成绩表 (姓名,班级,Java成绩) VALUES ('隔壁老王','g405班',90.5) #在插入时，可以省略掉后面的字段名，但必须全 INSERT INTO java成绩表 VALUES ('隔壁老王','g405班',90.5) #第二种方法 insert into 表名 set 字段名1=字段值1 INSERT INTO java成绩表 SET 姓名='李思'; #同时插入多条数据 INSERT INTO java成绩表 (姓名,班级,Java成绩) VALUES ('隔壁老王','g405班',90.5),('def','g405','90.6') # 删除数据语法：delete from 表名 where 条件 # 如果“=“是放在set关键字后面，则是”赋值运算符“ # 如果“=”是放在where 关键字后，则是“关系运算符” DELETE FROM java成绩表 WHERE 姓名='李思' #-------------------关系运算符--------------------------- #在mysql中常用的关系运算符有：=、\u0026gt;、\u0026gt;=、\u0026lt;、\u0026lt;=、!= #在mysql中关系运算符需要放置在where关键字之后 #查询语法规则：select 字段1，字段2....from 表名 (where 条件) # 1、查询某一张表中的所有数据记录 SELECT 姓名,班级,java成绩 FROM Java成绩表; SELECT 姓名 FROM Java成绩表; SELECT * FROM java成绩表;#*代表查询某一张表中的所有字段 SELECT 姓名 (AS 及格人员) FROM java成绩表 WHERE java成绩\u0026gt;=60; #------------逻辑运算符------------------ # 与and 或or 非not #给表取别名 SELECT * FROM java成绩表 s; #---------------------对表数据的增（create）删（delete）改（update）查（select）------------------------------- #修改语法 ：update 表名 set 字段名1=值1.... where 条件 UPDATE java成绩表 SET 班级='1' WHERE 姓名='李思' #删除 DELETE FROM java成绩表 WHERE #------------------------对sql语句进行分类-------------------------------------------- #数据库查询语言DQL（datebase query language）:对表的查询语句：select #数据库定义语言DDL（datebase defined language）:create database、create table、drop datebase、drop table、 #数据库操作语言DML（database manage language）:update、insert、delete #DDL之操作库 #添加数据库：create datebase 库名【character set utf8/gbk】 #删除指定的数据库：drop database 库名; #查询指定库的详细信息： (1)SHOW CREATE DATABASE 库名;查看某一个数据库的详细信息 SHOW CREATE DATABASE kzq; (2)SHOW DATABASES:查看mysql服务器软件下所有的库 (3)查看：当前用户连接的是哪个数据库：select DATABASE(); (4)查看指定的数据库下有哪些表:SHOW TABLES; #修改指定库的编码： alter database 库名 character set 新编码名; ALTER DATABASE dt55_account CHARACTER SET utf8; SHOW CREATE DATABASE dt55_account #--------------------------DDL之对表的增删改查----------------------------------- #创建一张表： CREATE TABLE 表名(字段名 数据类型,字段名2 数据类型....); #删除表： drop table 表名： #查询：(1)、查询某一张表的结构：desc（description） 表名 DESC bank; (2)、打印某一张表SQL创建信息： SHOW CREATE TABLE 表名; SHOW CREATE TABLE bank; #修改表： (1) RENAME TABLE 旧表名 TO 新表名; RENAME TABLE aaa TO bank; (2) 添加字段： ALTER TABLE 表名 ADD 字段名 数据类型; ALTER TABLE bank ADD gender VARCHAR(2); (3) 删除字段： ALTER TABLE 表名 DROP 被删除字段名; ALTER TABLE bank DROP gender; (4) 重命名字段 ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新字段名数据类型; ALTER TABLE bank CHANGE usenames aaa VARCHAR(40); (5) 修改数据类型(长度) ALTER TABLE bank CHANGE bankNo bankN0 VARCHAR(25); # --------------------数据库的备份和还原---------------------------------- #第一种通过命令：mysqldump -u root -p (密码) 需要备份的数据库名\u0026gt;备份后的sql脚本名; cmd-----\u0026gt;mysqldump -uu root -p (密码) dt55_account\u0026gt;c:\\dt55_account_back.sql 还原备份文件数据：进入mysql环境----\u0026gt;创建一个库----\u0026gt;在库下还原数据 source 备份数据库脚本 #第二种通过sqlyog工具:选中需要备份的数据库-----\u0026gt;右键------\u0026gt;备份/导出----\u0026gt;转储到sql #删除指定表字段 ALTER TABLE 表名 DROP 字段名 #--------------------数据类型属性-------------------------------- #mysql常见的数据类型：varchar（n）、float、int(n)、bigint(n)、date、datetime、text #默认值 default '默认值' #非空：NOT NULL 如果某一个字段别NOT NULL修饰后，添加数据时，此字段必需填写 #自动整长：auto_increment，尽量作用在int类型的字段上 #主键(唯一的，不能重复，一张表中只能以一个作为主键)：primary key #唯一健（唯一，可以有很多）：unique，被unique修饰的数据不能够重复 USE kzq; DROP TABLE students; CREATE TABLE students( id BIGINT(20) AUTO_INCREMENT PRIMARY KEY COMMENT '学生编号', stuName VARCHAR(40) COMMENT '学生姓名', gender VARCHAR(2) DEFAULT '男' COMMENT '性别', className VARCHAR(20) NOT NULL COMMENT '班级', phone VARCHAR(20) UNIQUE COMMENT '手机号码' ) #此处的delete可以删除整张表，但是删除数据后，自增列不会从1开始 DELETE FROM students WHERE id=1 () #如果要删除一整张表中的数据，使用truncate，使用truncate删除数据后，如果字段是自增的、则重新排列 TRUNCATE TABLE students; #================================================================ USE dt55_account; CREATE TABLE users( id BIGINT(20) NOT NULL AUTO_INCREMENT PRIMARY KEY COMMENT '用户编号', username VARCHAR(40) NOT NULL COMMENT '用户名', gender VARCHAR(2) DEFAULT '女' COMMENT '性别', idcard VARCHAR(20) UNIQUE NOT NULL COMMENT '身份证号', javaScore FLOAT DEFAULT '0' COMMENT 'java成绩' ) INSERT INTO users SET username='关雨',gender='男',idcard='110',javaScore=90; INSERT INTO users SET username='钱文雯',gender='男',idcard='120',javaScore=80; INSERT INTO users SET username='文儿',gender='男',idcard='911',javaScore=70; #---------------------------排序(order by 字段 降序，升序)--------------------------------------------- #降序(DESC) SELECT * FROM users ORDER BY javaScore DESC; #升序(ASC) SELECT * FROM users ORDER BY javaScore ASC; USE dt55_account; RENAME DATABASE 'dt55_account' TO 'class' #--------------------聚合函数----------------------------- SELECT 函数名（字段） FROM 表名 #找出最大值：max(字段) SELECT MAX(javaScore) AS 最高分 FROM users; #找出最小值：min(字段) SELECT MIN(javaScore) AS 最低分 FROM users; #求平均数：avg(字段名) SELECT AVG(javaScore) AS 平均分 FROM users; #求和 sum SELECT SUM(javaScore) AS 总分数 FROM users; #统计记录 count SELECT COUNT(*) FROM users #------------------常用函数--------------------- SELECT NOW() 年月日、时分秒 SELECT CURTIME() 时分秒 SELECT CURDATE() 年月日 SELECT CEIL(2.3) 向上取舍 SELECT FLOOR(2.3) 向下取舍 SELECT RAND() 返回0到1的随机数 #-------------------同时查询多条记录------------------------ SELECT * FROM users WHERE id IN (1,3) SELECT * FROM users WHERE id #分组查询group by 分类字段 #查询是否有种类为衣服的类型 SELECT goodcategory FROM goods GROUP BY goodcategory HAVING goodcategory='衣服' #分页 limit 起始下标，每页显示的数据量 #goods表中有七条数据记录，每一页显示三条，总共可以分3页 #获取第一页数据 SELECT * FROM goods LIMIT 0,3; #获取第二页数据 SELECT * FROM goods LIMIT 3,3; #获取第三页的数据 SELECT * FROM goods LIMIT 6,3; #复制某一张表 CREATE TABLE aaa( SELECT * FROM `bank` ); #插入数据 INSERT INTO aaa SELECT * FROM kzq.`java成绩表` #时间格式函数 SELECT DATE_FORMAT(DATE,'%Y年%m月%d日 %H:%i:%s') AS birthday FROM persons USE kzq #多表查询 DROP dept #部门表dept CREATE TABLE dept( id BIGINT(20) NOT NULL AUTO_INCREMENT PRIMARY KEY COMMENT '部门编号', deptName VARCHAR(20) COMMENT '部门名称' ) ID deptName(部门名称) 1 开发部 2 测试部 3 UI/前端部 4 销售部 #员工表emp ID empName(员工名字) salary deptID 1 光谷 8000 1 2 蔡光 8500 1 3 杨成全 9000 2 CREATE TABLE emp( id BIGINT(20) NOT NULL AUTO_INCREMENT PRIMARY KEY COMMENT '员工编号', empName VARCHAR(20) COMMENT '员工名', salary FLOAT COMMENT '薪水', deptId BIGINT(20) COMMENT '部门编号' ) #查询部门dept编号=1的部门下的所有员工 SELECT * FROM emp WHERE deptId=2 #查询所有员工 SELECT d.deptname,e.empName,e.salary FROM dept d,emp e WHERE d.deptname IN ('开发部','测试部') AND d.id=e.deptid SSSSs UNION 可以将两个查询语句的结果进行合并，合并的前提是两个查询语句的数据结构是一样的(如果有两个相同的数据，则自动去重) UNION ALL 不能去重、 #---------------------------------多表查询------------------------------------------ #多表查询语法1：select * from 表1,表2....表n where 条件 #多表查询方式： 内连接 外连接 左右连接 右外连接 #内连接：表1 inner join 表2 on 条件(多个表中有关联的条件) #查询所有部门中的所有员工 SELECT * FROM dept d,emp e WHERE d.id = e.deptId SELECT * FROM dept d INNER JOIN emp e ON d.id = e.deptId SELECT d.deptName,e.empName,e.salary FROM dept d INNER JOIN emp e ON d.id = e.deptId WHERE d.dept = '开发部' #on后面接几个表中有关联的条件，没有关联的条件用where #模糊查询 like a% 以a开头 %a 以a结尾 %a% 包含a # %占位符 #左外连接 left join 以左边的表为主，左边的表数据要显示出来 #右外连接 right join 以右边的表为主，右边的表数据要显示出来 #视图：在真实表上面构建的一张虚表 create view 视图名 as 查询语句; CREATE VIEW view_all AS SELECT e.empName,e.salary,d.deptname FROM dept d INNER JOIN emp e ON d.id = e.deptId; . DROP VIEW view_all; 视图的应用场景：在金融行业，保险行业，财务行业等 #数据库建模(powerDesinger) #事务：多组操作要么全部，要么全部失败 #开启事务： START TRANSACTION; #回滚事务： ROLLBACK; #提交事务 COMMIT; #事务的四大特性： #原子性：多组操作为一个整体，不能分割 #一致性：操作前后最终的总量一样 #隔离性：多个事务之间相互隔离互不干扰 #在mysql中事务有4种隔离级别：read uncommitted(读取未提交)、read committed(读取提交)、repeatable read(可以重复读)、Serializable #查看mysql软件的事务隔离级别:select @@tx_isolation; SELECT @@tx_isolation; #修改mysql软件默认的隔离级别：set global transaction isolation level 隔离级别 SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; #不同的隔离级别会引发不同的问题： #当mysql事务的隔离级别为read uncommitted时，会引发脏读：一个事务可以读取另一个事务未提交的数据 #如何解决脏读问题：可以将数据库事务的隔离级别改为:read committed SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED; #---------------------------------------------------------- #当mysql软件的事务隔离级别为:read committed的时候，会引发不可重复读：在同一事物中多次读取的结果不一致 #如何解决不可重复读：将事物的隔离级别改为repeatable read SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ; #当mysql软件的事务隔离级别为:repeatable read时，会引发虚读(幻读) #持久性：数据进入到数据库中后，数据需要持久存在 #-------------------------------------存储过程----------------------------------------------- #给员工加薪：加薪的金额(salary),员工编号(id) public BOOLEAN addSalary(FLOAT money,INT id){ 代码块; RETURN TRUE; } #存储过程语法： DELIMITER // CREATE PROCEDURE 存储过程名(参数名1 参数类型1,参数名2 参数类型2) BEGIN 代码块; END// DELIMITER ; #书写一个加薪的存储过程 #存储过程：是一组sql语句的集合 DELIMITER // CREATE PROCEDURE addSalary(money FLOAT,idd BIGINT) BEGIN UPDATE `emp` SET salary=salary+money WHERE id=idd; END// DELIMITER ; #调用存储过程:call 存储过程名() CALL `addSalary`(-1000,9); #删除存储过程 DROP PROCEDURE 存储过程名; DROP PROCEDURE `addSalary`; #----------------------带返回值的存储过程----------------------- #test1：传递两个float类型的形参，返回两个数的和 public FLOAT test1(FLOAT i,FLOAT j){ FLOAT num = i+j; RETURN num; } DELIMITER // CREATE PROCEDURE test1(IN i FLOAT,IN j FLOAT,OUT num FLOAT) BEGIN SET num=i+j; END// DELIMITER ; CALL `test1`(10,20,@result) SELECT @result #--------------------------------------mysql数据库高级部分之存储过程----------------------------------------------------- #创建存储过程的基本语法规则： DELIMITER // CREATE PROCEDURE 存储过程名(IN 输入参数名 参数类型,OUT 输出参数名 参数类型) BEGIN 代码块; END// DELIMITER ; #删除存储过程: DROP PROCEDURE 【if exists】 存储过程名; DROP PROCEDURE IF EXISTS test1; #调用存储过程 CALL 存储过程名(参数1...参数n); #带if语句的存储过程 #加薪的存储过程，传递两个参数：id、m(只能够传递整数，不能够传递负数) SELECT '亲，您输入的金额不能够为负数!!!' AS '友情提示'; DELIMITER // CREATE PROCEDURE pro_addSalary(idd BIGINT,m FLOAT) BEGIN IF m\u0026gt;0 THEN UPDATE users SET money=money+m WHERE id=idd; END IF; END// DELIMITER ; CALL `pro_addSalary`(1,-500); #带if..else的存储过程 DROP PROCEDURE IF EXISTS pro_salaryAdd; DELIMITER // CREATE PROCEDURE pro_salaryAdd(idd BIGINT,m FLOAT) BEGIN IF m\u0026gt;0 THEN UPDATE users SET money=money+m WHERE id=idd; ELSE SELECT '亲，您输入的金额不能够为负数!!!' AS '友情提示'; END IF; END// DELIMITER ; CALL `pro_salaryAdd`(1,-2000); #带if...else if...else语句的存储过程 #存储过程名:pro_buyCar(money float)，如果money\u0026gt;500万则买保时捷；否则如果money\u0026gt;300万，买宝马；否则如果money\u0026gt;10万买奥拓；否则骑摩拜 DELIMITER // CREATE PROCEDURE pro_buyCar(money FLOAT) BEGIN IF money\u0026gt;500 THEN SELECT '买保时捷' AS '买啥'; ELSEIF money\u0026gt;300 THEN SELECT '宝马' AS '买啥'; ELSEIF money\u0026gt;10 THEN SELECT '奥拓' AS '买啥'; ELSE SELECT '骑摩拜' AS '骑啥'; END IF; END// DELIMITER ; CALL `pro_buyCar`(5); #练习题：存储过程:pro_score(score float)，如果成绩\u0026gt;90分则是A等； #否则score\u0026gt;80B等；否则如果score\u0026gt;=60，C等；否则score\u0026lt;60，不及格 #case选择分支结构 #存储过程名:pro_case(i int)，如果i=1则打印星期一，i=2则打印星期二.... DELIMITER // CREATE PROCEDURE pro_case(i INT) BEGIN CASE i WHEN 1 THEN SELECT '星期一' AS '日期'; WHEN 2 THEN SELECT '星期二' AS '日期'; ELSE SELECT '今天不是周一或者周二，到底周几你猜？' AS '日期'; END CASE; END// DELIMITER ; CALL `pro_case`(3); #case练习：存储过程名:pro_case2(i int)， #如果i=1，则拨打\u0026quot;爸爸\u0026quot;的电话，如果i=2则拨打\u0026quot;妈妈\u0026quot;,否则：您打错了 DELIMITER // CREATE PROCEDURE pro_case2(i INT) BEGIN CASE i WHEN 1 THEN SELECT '拨打father的号码'; WHEN 2 THEN SELECT '拨打mother的号码'; ELSE SELECT '您打错了'; END CASE; END// DELIMITER ; CALL `pro_case2`(1); ####while循环 #Java中while循环的语法: WHILE(条件){ 循环体; 循环终止条件; } #存储过程名：pro_while2(i int)，如果i=100，则计算1到100之间的所有数之和，返回最终结果 DELIMITER // CREATE PROCEDURE pro_while2(IN i INT,OUT total INT) BEGIN DECLARE a INT DEFAULT 1; SET total=0; WHILE a\u0026lt;=i DO SET total=total+a; SET a=a+1; END WHILE; END// DELIMITER ; CALL `pro_while2`(100,@aaa); SELECT @aaa; #如果i=100则往users表中插入100条数据 DROP PROCEDURE IF EXISTS pro_while1; DELIMITER // CREATE PROCEDURE pro_while1(IN i INT) BEGIN DECLARE a INT DEFAULT 1; WHILE a\u0026lt;=i DO INSERT INTO `users` SET username='test',money=100; SET a=a+1; END WHILE; END// DELIMITER ; CALL pro_while1(10); SELECT COUNT(*) FROM users; TRUNCATE TABLE users; ###loop循环: CREATE PROCEDURE 存储过程名() BEGIN loop循环别名:LOOP 循环体; LEAVE loop循环别名; END LOOP; END; #----------------------- #通过loop循环往users表中同时添加100条记录 DELIMITER // CREATE PROCEDURE pro_loop() BEGIN DECLARE i INT DEFAULT 0; loop_test1:LOOP INSERT INTO `users` SET username='admin',money=200; SET i = i+1; IF i=100 THEN LEAVE loop_test1; END IF; END LOOP; END// DELIMITER ; CALL `pro_loop`(); #------------------------找出1-100之间能够被3整除的所有数之和----------------------------- DROP PROCEDURE IF EXISTS `pro_sum`; DELIMITER // CREATE PROCEDURE `pro_sum`() BEGIN DECLARE i INT DEFAULT 1; DECLARE total INT DEFAULT 0; WHILE i\u0026lt;=10 DO IF i MOD 3=0 THEN SET total=total+i; END IF; SET i = i+1;#循环结束条件 END WHILE; SELECT total; END// DELIMITER ; CALL `pro_sum`(); #作业 #书写一个存储过程，将`users`表中的所有money之和返回 SELECT SUM(money) FROM `users`; DELIMITER // CREATE PROCEDURE pro_qiuSum(OUT total FLOAT) BEGIN SELECT SUM(money) INTO total FROM `users`; END// DELIMITER ; CALL pro_qiuSum(@a); SELECT @a; # 2018年7月30日11:57:32用scrapy爬取豆瓣top250电影并存入数据库的一些查询语句 USE kzq; SELECT * FROM movies; SELECT id,title AS 爱情电影,movie_type,score FROM movies WHERE movie_type LIKE '%爱情%'; SELECT * FROM movies ORDER BY number DESC; SELECT id,title FROM movies WHERE country LIKE '%中国%' SELECT COUNT(*) FROM (SELECT id,title FROM movies WHERE country LIKE '%中国%') AS a SELECT COUNT(*) FROM movies SELECT title,COUNT(*) FROM movies GROUP BY country 获取电影类型中出现爱情的次数 SELECT SUM(CHAR_LENGTH(movie_type)-CHAR_LENGTH(REPLACE(movie_type,'爱情','')))/2 AS 剧情电影总数 FROM movies; 另一种写法 SELECT COUNT(*) FROM (SELECT id,title FROM movies WHERE movie_type LIKE '%爱情%')AS a  ","date":1540890390,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1540890390,"objectID":"2e66a82764fe3338b6bd32d0b3f47005","permalink":"https://kangzhiqing.com/post/mysql/","publishdate":"2018-10-30T17:06:30+08:00","relpermalink":"/post/mysql/","section":"post","summary":"mysql数据库是我今年暑假在家学习的，当时学习的时候写了一些笔记，现在把笔记整理到博客上。 Tips sql语句的语法Windows下是不区分大小写","tags":["数据库","关系型数据库","MySQL"],"title":"MySQL","type":"post"},{"authors":null,"categories":null,"content":" Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。我的博客网站就是通过Hugo来进行部署的,感谢Hugo,让我不需要重复造轮子. 官网:http://www.gohugo.org/ 1.下载 直接下载安装包 https://github.com/gohugoio/hugo/releases\n2.安装 windows10:解压安装包,会生成一个exe文件,在windows系统变量中添加当前路径到path.这样就算是安装成功了,之后都是在终端直接运行\n3.创建一个站点 hugo new site path/siteName 在path路径下生成一个叫siteName的站点  站点目录结构:\nsitname ├── archetypes │ └── default.md ├── config.toml 配置文件 ├── content 存放主要内容的目录 ├── data ├── layouts ├── static └── themes 主题目录  4.创建一篇文章 hugo new posts/blog.md 在content目录下生成posts/blog.md  5.下载主题和配置 url : https://themes.gohugo.io/\n(1)下载\n这些主题都托管在GitHub上,可以直接用git的下载方式下载 cd themes/ 进入themes目录 . git clone + 对应主题的地址 在readme.md中,作者会有对应git命令操作 . 直接在release最新发布版本中下载包  (2)配置 可以直接将下载的主题目录里面的 exampleSite/config.toml复制到站点根目录下覆盖初始化的config.toml文件 ( tip:注意config.toml文件中启用的主题名字是否和主题目录名一样,sam主题就是不一样的,不然就会加载主题失败 ) sam主题 ( https://themes.gohugo.io/hugo-theme-sam/ ) , 一个简约舒适的主题\n6.启动项目及部署 (1)启动本地服务 ▶ hugo server (--theme=\u0026lt;themeName\u0026gt;如果有多个主题可以进行选择) 一般在本地的1313端口运行 localhost:1313 or 127.0.0.1:1313 (2)部署到服务器中 ▶ hugo 会生成一个public的文件,如果要部署到服务器只要将该目录放到服务器之中 (类似于vue-cli的npm run build会生成一个dist目录的静态文件)  ","date":1540861893,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1540861893,"objectID":"894ecec029d0eb5908a28e83046e9787","permalink":"https://kangzhiqing.com/post/hugo/","publishdate":"2018-10-30T09:11:33+08:00","relpermalink":"/post/hugo/","section":"post","summary":"Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。我的博客网站就是通过Hugo来进行部署的,感谢Hugo,让我不","tags":["tool"],"title":"Hugo","type":"post"},{"authors":null,"categories":null,"content":" Hello World. This is my first blog. ","date":1540821580,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1540821580,"objectID":"3842110678af8aed7962464bf65102da","permalink":"https://kangzhiqing.com/post/helloworld/","publishdate":"2018-10-29T21:59:40+08:00","relpermalink":"/post/helloworld/","section":"post","summary":"Hello World. This is my first blog.","tags":["随记"],"title":"HelloWorld","type":"post"}]